{"mappings":"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","sources":["src/kuromoji.ts","src/Tokenizer.ts","src/viterbi/ViterbiBuilder.ts","src/util/SurrogateAwareString.ts","src/viterbi/ViterbiLattice.ts","src/viterbi/ViterbiNode.ts","src/viterbi/ViterbiSearcher.ts","src/dict/builder/DictionaryBuilder.ts","src/fst/FST.ts","src/fst/FSTBuilder.ts","src/util/DoubleArray.ts","src/dict/DynamicDictionaries.ts","src/dict/ConnectionCosts.ts","src/dict/TokenInfoDictionary.ts","src/util/ByteBuffer.ts","src/dict/UnknownDictionary.ts","src/dict/CharacterDefinition.ts","src/dict/CharacterClass.ts","src/dict/InvokeDefinitionMap.ts","src/dict/builder/CharacterDefinitionBuilder.ts","src/dict/builder/ConnectionCostsBuilder.ts","src/loader/DictionaryLoader.ts","src/util/BunCompressionStreams.ts","src/util/IpadicFormatter.ts","src/util/UnidicFormater.ts"],"sourcesContent":["import Tokenizer from \"./Tokenizer\";\nimport DictionaryBuilder from \"./dict/builder/DictionaryBuilder\";\nimport DictionaryLoader from \"./loader/DictionaryLoader\";\nimport type { Formatter } from \"./util/Formatter\";\nimport IpadicFormatter from \"./util/IpadicFormatter\";\nimport UnidicFormatter from \"./util/UnidicFormater\";\nimport type manifest from \"./util/manifest\";\nimport { type dicType } from \"./util/manifest\";\nimport { type Token } from \"./util/Formatter\";\n\nconst dic_formatter: Record<dicType, Formatter> = {\n\tIPAdic: new IpadicFormatter(),\n\tUniDic: new UnidicFormatter(),\n\t\"NAIST-jdic\": new IpadicFormatter(),\n};\n\n// Public methods\nconst kuromoji = {\n\tbuild: async (option: manifest) => {\n\t\tconst loader = new DictionaryLoader(option.dicPath);\n\t\tconst dic = await loader.load();\n\t\treturn new Tokenizer(dic, dic_formatter[option.dicType ?? \"IPAdic\"]);\n\t},\n\tdictionaryBuilder: () => new DictionaryBuilder(),\n};\n\nexport default kuromoji;\n","import type DynamicDictionaries from \"./dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"./dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"./dict/UnknownDictionary\";\nimport type { Formatter, Token } from \"./util/Formatter\";\nimport ViterbiBuilder from \"./viterbi/ViterbiBuilder\";\nimport type ViterbiLattice from \"./viterbi/ViterbiLattice\";\nimport ViterbiSearcher from \"./viterbi/ViterbiSearcher\";\n\nconst PUNCTUATION = /、|。/;\n\n/**\n * Tokenizer\n * @param {DynamicDictionaries} dic Dictionaries used by this tokenizer\n * @constructor\n */\nclass Tokenizer {\n\ttoken_info_dictionary: TokenInfoDictionary;\n\tunknown_dictionary: UnknownDictionary;\n\tviterbi_builder: ViterbiBuilder;\n\tviterbi_searcher: ViterbiSearcher;\n\tformatter: Formatter;\n\tconstructor(dic: DynamicDictionaries, formatter: Formatter) {\n\t\tthis.token_info_dictionary = dic.token_info_dictionary;\n\t\tthis.unknown_dictionary = dic.unknown_dictionary;\n\t\tthis.viterbi_builder = new ViterbiBuilder(dic);\n\t\tthis.viterbi_searcher = new ViterbiSearcher(dic.connection_costs);\n\t\tthis.formatter = formatter;\n\t}\n\t/**\n\t * Split into sentence by punctuation\n\t * @param {string} input Input text\n\t * @returns {Array.<string>} Sentences end with punctuation\n\t */\n\tstatic splitByPunctuation(input: string): Array<string> {\n\t\tconst sentences: string[] = [];\n\t\tlet tail = input;\n\t\twhile (true) {\n\t\t\tif (tail === \"\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst index = tail.search(PUNCTUATION);\n\t\t\tif (index < 0) {\n\t\t\t\tsentences.push(tail);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsentences.push(tail.substring(0, index + 1));\n\t\t\ttail = tail.substring(index + 1);\n\t\t}\n\t\treturn sentences;\n\t}\n\t/**\n\t * Tokenize text\n\t * @param {string} text Input text to analyze\n\t * @returns {Array} Tokens\n\t */\n\ttokenize(text: string): Token[] {\n\t\tconst sentences = Tokenizer.splitByPunctuation(text);\n\t\tconst tokens: Token[] = [];\n\t\tfor (let i = 0; i < sentences.length; i++) {\n\t\t\tconst sentence = sentences[i];\n\t\t\tthis.tokenizeForSentence(sentence, tokens);\n\t\t}\n\t\treturn tokens;\n\t}\n\ttokenizeForSentence(sentence: string, tokens: Token[] = []) {\n\t\tconst lattice = this.getLattice(sentence);\n\t\tconst best_path = this.viterbi_searcher.search(lattice);\n\t\tlet last_pos = 0;\n\t\tif (tokens.length > 0) {\n\t\t\tlast_pos = tokens[tokens.length - 1].word_position;\n\t\t}\n\n\t\tfor (let j = 0; j < best_path.length; j++) {\n\t\t\tconst node = best_path[j];\n\n\t\t\tlet token: Token;\n\t\t\tlet features: string[];\n\t\t\tlet features_line: string | undefined;\n\t\t\tif (node.type === \"KNOWN\") {\n\t\t\t\tfeatures_line = this.token_info_dictionary.getFeatures(\n\t\t\t\t\tnode.name.toString(),\n\t\t\t\t);\n\t\t\t\tif (features_line == null) {\n\t\t\t\t\tfeatures = [];\n\t\t\t\t} else {\n\t\t\t\t\tfeatures = features_line.split(\",\");\n\t\t\t\t}\n\t\t\t\ttoken = this.formatter.formatEntry(\n\t\t\t\t\tnode.name,\n\t\t\t\t\tlast_pos + node.start_pos,\n\t\t\t\t\tnode.type,\n\t\t\t\t\tfeatures,\n\t\t\t\t);\n\t\t\t} else if (node.type === \"UNKNOWN\") {\n\t\t\t\t// Unknown word\n\t\t\t\tfeatures_line = this.unknown_dictionary.getFeatures(\n\t\t\t\t\tnode.name.toString(),\n\t\t\t\t);\n\t\t\t\tif (features_line == null) {\n\t\t\t\t\tfeatures = [];\n\t\t\t\t} else {\n\t\t\t\t\tfeatures = features_line.split(\",\");\n\t\t\t\t}\n\t\t\t\ttoken = this.formatter.formatUnknownEntry(\n\t\t\t\t\tnode.name,\n\t\t\t\t\tlast_pos + node.start_pos,\n\t\t\t\t\tnode.type,\n\t\t\t\t\tfeatures,\n\t\t\t\t\tnode.surface_form,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// TODO User dictionary\n\t\t\t\ttoken = this.formatter.formatEntry(\n\t\t\t\t\tnode.name,\n\t\t\t\t\tlast_pos + node.start_pos,\n\t\t\t\t\tnode.type,\n\t\t\t\t\t[],\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttokens.push(token);\n\t\t}\n\n\t\treturn tokens;\n\t}\n\t/**\n\t * Build word lattice\n\t * @param {string} text Input text to analyze\n\t * @returns {ViterbiLattice} Word lattice\n\t */\n\tgetLattice(text: string): ViterbiLattice {\n\t\treturn this.viterbi_builder.build(text);\n\t}\n}\n\nexport default Tokenizer;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type DynamicDictionaries from \"../dict/DynamicDictionaries\";\nimport type { WordSearch } from \"../dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"../dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"../dict/UnknownDictionary\";\nimport SurrogateAwareString from \"../util/SurrogateAwareString\";\nimport ViterbiLattice from \"./ViterbiLattice\";\nimport ViterbiNode from \"./ViterbiNode\";\n\n/**\n * ViterbiBuilder builds word lattice (ViterbiLattice)\n * @param {DynamicDictionaries} dic dictionary\n * @constructor\n */\nclass ViterbiBuilder {\n\tword: WordSearch;\n\ttoken_info_dictionary: TokenInfoDictionary;\n\tunknown_dictionary: UnknownDictionary;\n\tconstructor(dic: DynamicDictionaries) {\n\t\tthis.word = dic.word;\n\t\tthis.token_info_dictionary = dic.token_info_dictionary;\n\t\tthis.unknown_dictionary = dic.unknown_dictionary;\n\t}\n\t/**\n\t * Build word lattice\n\t * @param {string} sentence_str Input text\n\t * @returns {ViterbiLattice} Word lattice\n\t */\n\tbuild(sentence_str: string): ViterbiLattice {\n\t\tconst lattice = new ViterbiLattice();\n\t\tconst sentence = new SurrogateAwareString(sentence_str);\n\n\t\tlet key: string;\n\t\tlet trie_id: number;\n\t\tlet left_id: number;\n\t\tlet right_id: number;\n\t\tlet word_cost: number;\n\t\tfor (let pos = 0; pos < sentence.length; pos++) {\n\t\t\tconst tail = sentence.slice(pos);\n\t\t\tconst vocabulary = this.word.commonPrefixSearch(tail);\n\t\t\t// console.log(vocabulary)\n\t\t\t// console.log(vocabulary.length)\n\t\t\tfor (let n = 0; n < vocabulary.length; n++) {\n\t\t\t\t// Words in dictionary do not have surrogate pair (only UCS2 set)\n\t\t\t\ttrie_id = vocabulary[n].v;\n\t\t\t\tkey = vocabulary[n].k;\n\n\t\t\t\tconst token_info_ids = this.token_info_dictionary.target_map[trie_id];\n\t\t\t\t// console.log(key)\n\t\t\t\t// console.log(token_info_ids)\n\t\t\t\tfor (let i = 0; i < token_info_ids.length; i++) {\n\t\t\t\t\tconst token_info_id = Number.parseInt(token_info_ids[i].toString());\n\n\t\t\t\t\tleft_id =\n\t\t\t\t\t\tthis.token_info_dictionary.dictionary.getShort(token_info_id);\n\t\t\t\t\tright_id = this.token_info_dictionary.dictionary.getShort(\n\t\t\t\t\t\ttoken_info_id + 2,\n\t\t\t\t\t);\n\t\t\t\t\tword_cost = this.token_info_dictionary.dictionary.getShort(\n\t\t\t\t\t\ttoken_info_id + 4,\n\t\t\t\t\t);\n\n\t\t\t\t\t// node_name, cost, start_index, length, type, left_id, right_id, surface_form\n\t\t\t\t\tlattice.append(\n\t\t\t\t\t\tnew ViterbiNode(\n\t\t\t\t\t\t\ttoken_info_id,\n\t\t\t\t\t\t\tword_cost,\n\t\t\t\t\t\t\tpos + 1,\n\t\t\t\t\t\t\tkey.length,\n\t\t\t\t\t\t\t\"KNOWN\",\n\t\t\t\t\t\t\tleft_id,\n\t\t\t\t\t\t\tright_id,\n\t\t\t\t\t\t\tkey.toString(),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unknown word processing\n\t\t\tconst surrogate_aware_tail = new SurrogateAwareString(tail);\n\t\t\tconst head_char = new SurrogateAwareString(\n\t\t\t\tsurrogate_aware_tail.charAt(0),\n\t\t\t);\n\t\t\tconst head_char_class = this.unknown_dictionary.lookup(\n\t\t\t\thead_char.toString(),\n\t\t\t);\n\t\t\tif (\n\t\t\t\tvocabulary == null ||\n\t\t\t\tvocabulary.length === 0 ||\n\t\t\t\thead_char_class.is_always_invoke\n\t\t\t) {\n\t\t\t\tlet key: SurrogateAwareString;\n\t\t\t\t// Process unknown word\n\t\t\t\tkey = head_char;\n\t\t\t\tif (head_char_class.is_grouping && 1 < surrogate_aware_tail.length) {\n\t\t\t\t\tfor (let k = 1; k < surrogate_aware_tail.length; k++) {\n\t\t\t\t\t\tconst next_char = surrogate_aware_tail.charAt(k);\n\t\t\t\t\t\tconst next_char_class = this.unknown_dictionary.lookup(next_char);\n\t\t\t\t\t\tif (head_char_class.class_name !== next_char_class.class_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkey = new SurrogateAwareString(key.str + next_char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst unk_ids =\n\t\t\t\t\tthis.unknown_dictionary.target_map[head_char_class.class_id];\n\t\t\t\tfor (let j = 0; j < unk_ids.length; j++) {\n\t\t\t\t\tconst unk_id = Number.parseInt(unk_ids[j].toString());\n\n\t\t\t\t\tleft_id = this.unknown_dictionary.dictionary.getShort(unk_id);\n\t\t\t\t\tright_id = this.unknown_dictionary.dictionary.getShort(unk_id + 2);\n\t\t\t\t\tword_cost = this.unknown_dictionary.dictionary.getShort(unk_id + 4);\n\n\t\t\t\t\t// node_name, cost, start_index, length, type, left_id, right_id, surface_form\n\t\t\t\t\tlattice.append(\n\t\t\t\t\t\tnew ViterbiNode(\n\t\t\t\t\t\t\tunk_id,\n\t\t\t\t\t\t\tword_cost,\n\t\t\t\t\t\t\tpos + 1,\n\t\t\t\t\t\t\tkey.length,\n\t\t\t\t\t\t\t\"UNKNOWN\",\n\t\t\t\t\t\t\tleft_id,\n\t\t\t\t\t\t\tright_id,\n\t\t\t\t\t\t\tkey.toString(),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlattice.appendEos();\n\n\t\treturn lattice;\n\t}\n}\n\nexport default ViterbiBuilder;\n","/**\n * String wrapper for UTF-16 surrogate pair (4 bytes)\n * @param {string} str String to wrap\n * @constructor\n */\nclass SurrogateAwareString {\n\tstr: string;\n\tindex_mapping: number[];\n\tlength: number;\n\tconstructor(str: string) {\n\t\tthis.str = str;\n\t\tthis.index_mapping = [];\n\n\t\tfor (let pos = 0; pos < str.length; pos++) {\n\t\t\tconst ch = str.charAt(pos);\n\t\t\tthis.index_mapping.push(pos);\n\t\t\tif (SurrogateAwareString.isSurrogatePair(ch)) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\t// Surrogate aware length\n\t\tthis.length = this.index_mapping.length;\n\t}\n\tstatic isSurrogatePair(ch: string) {\n\t\tconst utf16_code = ch.charCodeAt(0);\n\t\tif (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n\t\t\t// surrogate pair\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tslice(index: number) {\n\t\tif (this.index_mapping.length <= index) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst surrogate_aware_index = this.index_mapping[index];\n\t\treturn this.str.slice(surrogate_aware_index);\n\t}\n\tcharAt(index: number) {\n\t\tif (this.str.length <= index) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst surrogate_aware_start_index = this.index_mapping[index];\n\t\tconst surrogate_aware_end_index = this.index_mapping[index + 1];\n\n\t\tif (surrogate_aware_end_index == null) {\n\t\t\treturn this.str.slice(surrogate_aware_start_index);\n\t\t}\n\t\treturn this.str.slice(\n\t\t\tsurrogate_aware_start_index,\n\t\t\tsurrogate_aware_end_index,\n\t\t);\n\t}\n\tcharCodeAt(index: number) {\n\t\tif (this.index_mapping.length <= index) {\n\t\t\treturn Number.NaN;\n\t\t}\n\t\tconst surrogate_aware_index = this.index_mapping[index];\n\t\tconst upper = this.str.charCodeAt(surrogate_aware_index);\n\t\tlet lower: number;\n\t\tif (\n\t\t\tupper >= 0xd800 &&\n\t\t\tupper <= 0xdbff &&\n\t\t\tsurrogate_aware_index < this.str.length\n\t\t) {\n\t\t\tlower = this.str.charCodeAt(surrogate_aware_index + 1);\n\t\t\tif (lower >= 0xdc00 && lower <= 0xdfff) {\n\t\t\t\treturn (upper - 0xd800) * 0x400 + lower - 0xdc00 + 0x10000;\n\t\t\t}\n\t\t}\n\t\treturn upper;\n\t}\n\ttoString() {\n\t\treturn this.str;\n\t}\n}\n\nexport default SurrogateAwareString;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport ViterbiNode from \"./ViterbiNode\";\n\n/**\n * ViterbiLattice is a lattice in Viterbi algorithm\n * @constructor\n */\nclass ViterbiLattice {\n\tnodes_end_at: ViterbiNode[][];\n\teos_pos: number;\n\n\tconstructor() {\n\t\tthis.nodes_end_at = [];\n\t\tthis.nodes_end_at[0] = [new ViterbiNode(-1, 0, 0, 0, \"BOS\", 0, 0, \"\")];\n\t\tthis.eos_pos = 1;\n\t}\n\t/**\n\t * Append node to ViterbiLattice\n\t * @param {ViterbiNode} node\n\t */\n\tappend(node: ViterbiNode) {\n\t\tconst last_pos = node.start_pos + node.length - 1;\n\t\tif (this.eos_pos < last_pos) {\n\t\t\tthis.eos_pos = last_pos;\n\t\t}\n\n\t\tlet prev_nodes = this.nodes_end_at[last_pos];\n\t\tif (prev_nodes == null) {\n\t\t\tprev_nodes = [];\n\t\t}\n\t\tprev_nodes.push(node);\n\n\t\tthis.nodes_end_at[last_pos] = prev_nodes;\n\t}\n\t/**\n\t * Set ends with EOS (End of Statement)\n\t */\n\tappendEos() {\n\t\tconst last_index = this.nodes_end_at.length;\n\t\tthis.eos_pos++;\n\t\tthis.nodes_end_at[last_index] = [\n\t\t\tnew ViterbiNode(-1, 0, this.eos_pos, 0, \"EOS\", 0, 0, \"\"),\n\t\t];\n\t}\n}\n\nexport default ViterbiLattice;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * ViterbiNode is a node of ViterbiLattice\n * @param {number} node_name Word ID\n * @param {number} node_cost Word cost to generate\n * @param {number} start_pos Start position from 1\n * @param {number} length Word length\n * @param {string} type Node type (KNOWN, UNKNOWN, BOS, EOS, ...)\n * @param {number} left_id Left context ID\n * @param {number} right_id Right context ID\n * @param {string} surface_form Surface form of this word\n * @constructor\n */\nclass ViterbiNode {\n\tname: number;\n\tcost: number;\n\tstart_pos: number;\n\tlength: number;\n\tleft_id: number;\n\tright_id: number;\n\tprev: ViterbiNode | null;\n\tsurface_form: string;\n\tshortest_cost: number;\n\ttype: string;\n\n\tconstructor(\n\t\tnode_name: number,\n\t\tnode_cost: number,\n\t\tstart_pos: number,\n\t\tlength: number,\n\t\ttype: string,\n\t\tleft_id: number,\n\t\tright_id: number,\n\t\tsurface_form: string,\n\t) {\n\t\tthis.name = node_name;\n\t\tthis.cost = node_cost;\n\t\tthis.start_pos = start_pos;\n\t\tthis.length = length;\n\t\tthis.left_id = left_id;\n\t\tthis.right_id = right_id;\n\t\tthis.prev = null;\n\t\tthis.surface_form = surface_form;\n\t\tif (type === \"BOS\") {\n\t\t\tthis.shortest_cost = 0;\n\t\t} else {\n\t\t\tthis.shortest_cost = Number.MAX_VALUE;\n\t\t}\n\t\tthis.type = type;\n\t}\n}\n\nexport default ViterbiNode;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type ConnectionCosts from \"../dict/ConnectionCosts\";\nimport type ViterbiLattice from \"./ViterbiLattice\";\nimport type ViterbiNode from \"./ViterbiNode\";\n\n/**\n * ViterbiSearcher is for searching best Viterbi path\n * @param {ConnectionCosts} connection_costs Connection costs matrix\n * @constructor\n */\nclass ViterbiSearcher {\n\tconnection_costs: ConnectionCosts;\n\tconstructor(connection_costs: ConnectionCosts) {\n\t\tthis.connection_costs = connection_costs;\n\t}\n\t/**\n\t * Search best path by forward-backward algorithm\n\t * @param {ViterbiLattice} lattice Viterbi lattice to search\n\t * @returns {Array} Shortest path\n\t */\n\tsearch(lattice: ViterbiLattice): ViterbiNode[] {\n\t\tconst foewarded_lattice = this.forward(lattice);\n\t\treturn this.backward(foewarded_lattice);\n\t}\n\tforward(lattice: ViterbiLattice) {\n\t\tlet i: number;\n\t\tlet j: number;\n\t\tlet k: number;\n\t\tfor (i = 1; i <= lattice.eos_pos; i++) {\n\t\t\tconst nodes = lattice.nodes_end_at[i];\n\t\t\tif (nodes == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0; j < nodes.length; j++) {\n\t\t\t\tconst node = nodes[j];\n\t\t\t\tlet cost = Number.MAX_VALUE;\n\t\t\t\tlet shortest_prev_node: ViterbiNode | null = null;\n\n\t\t\t\tconst prev_nodes = lattice.nodes_end_at[node.start_pos - 1];\n\t\t\t\tif (prev_nodes == null) {\n\t\t\t\t\t// TODO process unknown words (repair word lattice)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < prev_nodes.length; k++) {\n\t\t\t\t\tconst prev_node = prev_nodes[k];\n\n\t\t\t\t\tlet edge_cost: number;\n\t\t\t\t\tif (node.left_id == null || prev_node.right_id == null) {\n\t\t\t\t\t\t// TODO assert\n\t\t\t\t\t\tconsole.log(\"Left or right is null\");\n\t\t\t\t\t\tedge_cost = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedge_cost = this.connection_costs.get(\n\t\t\t\t\t\t\tprev_node.right_id,\n\t\t\t\t\t\t\tnode.left_id,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst _cost = prev_node.shortest_cost + edge_cost + node.cost;\n\t\t\t\t\tif (_cost < cost) {\n\t\t\t\t\t\tshortest_prev_node = prev_node;\n\t\t\t\t\t\tcost = _cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnode.prev = shortest_prev_node;\n\t\t\t\tnode.shortest_cost = cost;\n\t\t\t}\n\t\t}\n\t\treturn lattice;\n\t}\n\tbackward(lattice: ViterbiLattice) {\n\t\tconst shortest_path: ViterbiNode[] = [];\n\t\tconst eos = lattice.nodes_end_at[lattice.nodes_end_at.length - 1][0];\n\n\t\tlet node_back = eos.prev;\n\t\tif (node_back == null) {\n\t\t\treturn [];\n\t\t}\n\t\twhile (node_back.type !== \"BOS\") {\n\t\t\tshortest_path.push(node_back);\n\t\t\tif (node_back.prev == null) {\n\t\t\t\t// TODO Failed to back. Process unknown words?\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tnode_back = node_back.prev;\n\t\t}\n\n\t\treturn shortest_path.reverse();\n\t}\n}\n\nexport default ViterbiSearcher;\n","import { compileFST, FST, Matcher } from \"../../fst/FST\";\nimport { FSTBuilder } from \"../../fst/FSTBuilder\";\nimport { type DoubleArray, builder as _builder } from \"../../util/DoubleArray\";\nimport DynamicDictionaries, { type WordSearch } from \"../DynamicDictionaries\";\nimport TokenInfoDictionary from \"../TokenInfoDictionary\";\nimport UnknownDictionary from \"../UnknownDictionary\";\nimport CharacterDefinitionBuilder from \"./CharacterDefinitionBuilder\";\nimport ConnectionCostsBuilder from \"./ConnectionCostsBuilder\";\n\n/**\n * Build dictionaries (token info, connection costs)\n *\n * Generates from matrix.def\n * cc.dat: Connection costs\n *\n * Generates from *.csv\n * dat.dat: Double array\n * tid.dat: Token info dictionary\n * tid_map.dat: targetMap\n * tid_pos.dat: posList (part of speech)\n */\nclass DictionaryBuilder {\n\ttid_entries: string[][];\n\tunk_entries: string[][];\n\tcc_builder: ConnectionCostsBuilder;\n\tcd_builder: CharacterDefinitionBuilder;\n\tconstructor() {\n\t\t// Array of entries, each entry in Mecab form\n\t\t// (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n\t\tthis.tid_entries = [];\n\t\tthis.unk_entries = [];\n\t\tthis.cc_builder = new ConnectionCostsBuilder();\n\t\tthis.cd_builder = new CharacterDefinitionBuilder();\n\t}\n\taddTokenInfoDictionary(new_entry: string) {\n\t\tthis.tid_entries.push(new_entry.split(\",\"));\n\t\treturn this;\n\t}\n\t/**\n\t * Put one line of \"matrix.def\" file for building ConnectionCosts object\n\t * @param {string} line is a line of \"matrix.def\"\n\t */\n\tputCostMatrixLine(line: string) {\n\t\tthis.cc_builder.putLine(line);\n\t\treturn this;\n\t}\n\tputCharDefLine(line: string) {\n\t\tthis.cd_builder.putLine(line);\n\t\treturn this;\n\t}\n\t/**\n\t * Put one line of \"unk.def\" file for building UnknownDictionary object\n\t * @param {string[]} new_entry is a line of \"unk.def\"\n\t */\n\tputUnkDefLine(new_entry: string) {\n\t\tthis.unk_entries.push(new_entry.split(\",\"));\n\t\treturn this;\n\t}\n\tbuild(isTrie: boolean = true) {\n\t\tconst dictionaries = this.buildTokenInfoDictionary(isTrie);\n\t\tconst unknown_dictionary = this.buildUnknownDictionary();\n\t\tif (dictionaries.word.fst){\n\t\t\treturn new DynamicDictionaries(\n\t\t\t\tdictionaries.word.fst,\n\t\t\t\tdictionaries.token_info_dictionary,\n\t\t\t\tthis.cc_builder.build(),\n\t\t\t\tunknown_dictionary,\n\t\t\t);\n\t\t} else {\n\t\t\treturn new DynamicDictionaries(\n\t\t\t\tdictionaries.word.trie,\n\t\t\t\tdictionaries.token_info_dictionary,\n\t\t\t\tthis.cc_builder.build(),\n\t\t\t\tunknown_dictionary,\n\t\t\t);\n\t\t}\n\t\t\n\t}\n\tbuildAll() {\n\t\tconst dictionaries = this.buildTokenInfoDictionary(true, true);\n\t\tconst unknown_dictionary = this.buildUnknownDictionary();\n\n\t\treturn {\n\t\t\tdic: new DynamicDictionaries(\n\t\t\t\tundefined,\n\t\t\t\tdictionaries.token_info_dictionary,\n\t\t\t\tthis.cc_builder.build(),\n\t\t\t\tunknown_dictionary,\n\t\t\t),\n\t\t\tword: dictionaries.word\n\t\t}\n\t}\n\t/**\n\t * Build TokenInfoDictionary\n\t *\n\t * @returns {{trie: WordSearch, token_info_dictionary: TokenInfoDictionary}}\n\t */\n\tbuildTokenInfoDictionary(isTrie = true, all = false): {\n\t\tword: {fst?: WordSearch, trie?: WordSearch};\n\t\ttoken_info_dictionary: TokenInfoDictionary;\n\t} {\n\t\tconst token_info_dictionary = new TokenInfoDictionary();\n\n\t\t// using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\t\tconst dictionary_entries = token_info_dictionary.buildDictionary(\n\t\t\tthis.tid_entries,\n\t\t);\n\t\tlet fst: Matcher | undefined\n\t\tlet trie: DoubleArray | undefined\n\n\t\tif (all) {\n\t\t\tfst = this.buildFST()\n\t\t\ttrie = this.buildDoubleArray()\n\t\t} else if (isTrie){\n\t\t\ttrie = this.buildDoubleArray()\n\t\t}else{\n\t\t\tfst = this.buildFST()\n\t\t}\n\n\t\tfor (const token_info_id in dictionary_entries) {\n\t\t\tconst surface_form = dictionary_entries[token_info_id];\n\t\t\t\n\t\t\tconst trie_id = (isTrie ? trie! : fst!).lookup(surface_form);\n\n\t\t\t// Assertion\n\t\t\tif (trie_id < 0) {\n\t\t\t    console.log(\"Not Found:\" + surface_form);\n\t\t\t}\n\t\t\ttoken_info_dictionary.addMapping(trie_id, token_info_id);\n\t\t}\n\n\t\treturn {\n\t\t\tword:{\n\t\t\t\ttrie: trie,\n\t\t\t\tfst: fst\n\t\t\t},\n\t\t\ttoken_info_dictionary: token_info_dictionary,\n\t\t};\n\t}\n\tbuildUnknownDictionary() {\n\t\tconst unk_dictionary = new UnknownDictionary();\n\n\t\t// using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\t\tconst dictionary_entries = unk_dictionary.buildDictionary(this.unk_entries);\n\n\t\tconst char_def = this.cd_builder.build(); // Create CharacterDefinition\n\n\t\tif (!char_def.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\n\t\tunk_dictionary.characterDefinition(char_def);\n\n\t\tfor (const token_info_id in dictionary_entries) {\n\t\t\tconst class_name = dictionary_entries[token_info_id];\n\t\t\tconst class_id = char_def.invoke_definition_map.lookup(class_name);\n\n\t\t\t// Assertion\n\t\t\t// if (trie_id < 0) {\n\t\t\t//     console.log(\"Not Found:\" + surface_form);\n\t\t\t// }\n\t\t\tunk_dictionary.addMapping(class_id, token_info_id);\n\t\t}\n\n\t\treturn unk_dictionary;\n\t}\n\n\tbuildFST(): Matcher {\n\t\tlet trie_id = 0;\n\t\tconst words = this.tid_entries.map((entry) => {\n\t\t\tconst surface_form = entry[0];\n\t\t\treturn { k: surface_form, v: trie_id++ };\n\t\t});\n\n\t\tconst builder = new FSTBuilder();\n\t\tconst fst = builder.build(words);\n\t\tconst bin = compileFST(fst);\n\t\treturn new Matcher(bin)\n\t}\n\t/**\n\t * Build double array trie\n\t *\n\t * @returns {DoubleArray} Double-Array trie\n\t */\n\tbuildDoubleArray(): DoubleArray {\n\t\tlet trie_id = 0;\n\t\tconst words = this.tid_entries.map((entry) => {\n\t\t\tconst surface_form = entry[0];\n\t\t\treturn { k: surface_form, v: trie_id++ };\n\t\t});\n\n\t\tconst builder = _builder(1024 * 1024);\n\t\treturn builder.build(words);\n\t}\n}\n\nexport default DictionaryBuilder;\n","import type { WordSearch } from \"../dict/DynamicDictionaries\";\n\ninterface internalKeyValue {\n\tk: Uint8Array;\n\tv: Uint8Array;\n}\n\ninterface externalKeyValue {\n\tk: string;\n\tv: number;\n}\n\n// Bit flags for arc representation\nconst FLAG_FINAL_ARC = 1 << 0;\nconst FLAG_LAST_ARC = 1 << 1;\nconst FLAG_ARC_HAS_OUTPUT = 1 << 4;\nconst FLAG_ARC_HAS_FINAL_OUTPUT = 1 << 5;\nconst NOT_FOUND = -1;\ninterface Transition {\n\tstate: State;\n\toutput: Uint8Array;\n}\n\ninterface TransitionMap {\n\t[key: number]: Transition;\n}\n\nclass State {\n\tid: number | null;\n\tfinal: boolean;\n\ttransMap: TransitionMap;\n\tfinalOutput: Set<Uint8Array>;\n\n\tconstructor(id: number | null = null) {\n\t\tthis.id = id;\n\t\tthis.final = false;\n\t\tthis.transMap = {};\n\t\tthis.finalOutput = new Set();\n\t}\n\n\tisFinal(): boolean {\n\t\treturn this.final;\n\t}\n\n\tsetFinal(final: boolean): void {\n\t\tthis.final = final;\n\t}\n\n\ttransition(char: number): State | null {\n\t\treturn this.transMap[char]?.state || null;\n\t}\n\n\tsetTransition(char: number, state: State): void {\n\t\tthis.transMap[char] = {\n\t\t\tstate,\n\t\t\toutput: this.transMap[char]?.output || new Uint8Array(),\n\t\t};\n\t}\n\n\tstateOutput(): Set<Uint8Array> {\n\t\treturn this.finalOutput;\n\t}\n\n\tsetStateOutput(output: Set<Uint8Array>): void {\n\t\tthis.finalOutput = new Set(\n\t\t\tArray.from(output).map((e) => new Uint8Array(e)),\n\t\t);\n\t}\n\n\tclearStateOutput(): void {\n\t\tthis.finalOutput.clear();\n\t}\n\n\toutput(char: number): Uint8Array {\n\t\treturn this.transMap[char]?.output || new Uint8Array();\n\t}\n\n\tsetOutput(char: number, out: Uint8Array): void {\n\t\tif (this.transMap[char]) {\n\t\t\tthis.transMap[char].output = new Uint8Array(out);\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis.final = false;\n\t\tthis.transMap = {};\n\t\tthis.finalOutput.clear();\n\t}\n}\n\nclass FST {\n\tpublic dictionary: Map<string, State>;\n\n\tconstructor() {\n\t\tthis.dictionary = new Map();\n\t}\n\n\tsize(): number {\n\t\treturn this.dictionary.size;\n\t}\n\n\tmember(state: State): State | undefined {\n\t\treturn this.dictionary.get(this.hashState(state));\n\t}\n\n\tinsert(state: State): void {\n\t\tthis.dictionary.set(this.hashState(state), state);\n\t}\n\n\tprivate hashState(state: State): string {\n        return JSON.stringify({\n            final: state.final,\n            transMap: state.transMap,\n            finalOutput: Array.from(state.finalOutput)\n        });\n\t}\n}\n\ninterface Arc {\n\tflag: number;\n\tlabel: number;\n\toutput: Uint8Array;\n\tfinalOutput: Uint8Array[];\n\ttarget: number;\n}\n\nclass Matcher implements WordSearch {\n\tprivate static readonly BUF_SIZE = 1024;\n\tprivate data: Uint8Array;\n\n\tconstructor(dictData?: Uint8Array) {\n\t\tif (dictData) {\n\t\t\tthis.data = dictData;\n\t\t} else {\n\t\t\tthrow new Error(\"dictData must be provided\");\n\t\t}\n\t}\n\n\trun(word: Uint8Array): [boolean, Set<Uint8Array>] {\n\t\tconst outputs = new Set<Uint8Array>();\n\t\tlet accept = false;\n\t\tlet buf = new Uint8Array();\n\t\tlet i = 0;\n\t\tlet pos = 0;\n\n\t\twhile (pos < this.data.length) {\n\t\t\tconst [arc, incr] = this.nextArc(pos);\n\n\t\t\tif (arc.flag & FLAG_FINAL_ARC) {\n\t\t\t\taccept = (i === word.length);\n\t\t\t\tif(accept){\n\t\t\t\t\tarc.finalOutput.forEach((out) => {\n\t\t\t\t\t\tconst newOutput = new Uint8Array(buf.length + out.length);\n\t\t\t\t\t\tnewOutput.set(buf);\n\t\t\t\t\t\tnewOutput.set(out, buf.length);\n\t\t\t\t\t\toutputs.add(newOutput);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (arc.flag & FLAG_LAST_ARC || i >= word.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos += incr;\n\t\t\t} else if (arc.flag & FLAG_LAST_ARC) {\n\t\t\t\tif (i >= word.length) break;\n\t\t\t\tif (word[i] === arc.label) {\n\t\t\t\t\tconst newBuf = new Uint8Array(buf.length + arc.output.length);\n\t\t\t\t\tnewBuf.set(buf);\n\t\t\t\t\tnewBuf.set(arc.output, buf.length);\n\t\t\t\t\tbuf = newBuf;\n\t\t\t\t\ti++;\n\t\t\t\t\tpos += arc.target;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (i >= word.length) break;\n\t\t\t\tif (word[i] === arc.label) {\n\t\t\t\t\tconst newBuf = new Uint8Array(buf.length + arc.output.length);\n\t\t\t\t\tnewBuf.set(buf);\n\t\t\t\t\tnewBuf.set(arc.output, buf.length);\n\t\t\t\t\tbuf = newBuf;\n\t\t\t\t\ti++;\n\t\t\t\t\tpos += arc.target;\n\t\t\t\t} else {\n\t\t\t\t\tpos += incr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [accept, outputs];\n\t}\n\n\tlookup(key: string): number {\n\t\tconst textEncoder = new TextEncoder()\n\t\tconst textDecoder = new TextDecoder()\n\t\tconst [accept, encoded_word] = this.run(textEncoder.encode(key));\n\t\tif(!accept)\n\t\t\treturn NOT_FOUND\n\n\t\tlet result: Uint8Array = Array.from(encoded_word)[0]\n\n\t\treturn parseInt(textDecoder.decode(result))\n\t}\n\n\tcommonPrefixSearch(word: string): externalKeyValue[] {\n\t\tconst textEncoder = new TextEncoder();\n\t\tconst textDecoder = new TextDecoder();\n\t\tconst buffer = textEncoder.encode(word);\n\n\t\tconst searchResult: externalKeyValue[] = []\n\t\tfor (let i = 1; i <= buffer.length; i++) {\n\t\t\tconst [accepted, result] = this.run(buffer.slice(0, i));\n\t\t\tif(!accepted){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst arrayed = Array.from(result)\n\n\t\t\tconst tmp_searchResult = arrayed.map<externalKeyValue>((enc_output) =>\n\t\t\t({\n\t\t\t\tk: textDecoder.decode(buffer.slice(0, i)),\n\t\t\t\tv: Number.parseInt(textDecoder.decode(enc_output)),\n\t\t\t})\n\t\t\t)\n\t\t\tsearchResult.push(tmp_searchResult[0]);\n\t\t}\n\t\t\n\t\treturn searchResult\n\t}\n\n\tprivate nextArc(addr: number): [Arc, number] {\n\t\tconst arc: Arc = {\n\t\t\tflag: 0,\n\t\t\tlabel: 0,\n\t\t\toutput: new Uint8Array(),\n\t\t\tfinalOutput: [new Uint8Array()],\n\t\t\ttarget: 0,\n\t\t};\n\n\t\tlet pos = addr;\n\t\tarc.flag = new DataView(this.data.buffer).getInt8(pos);\n\t\tpos += 1;\n\n\t\tif (arc.flag & FLAG_FINAL_ARC) {\n\t\t\tif (arc.flag & FLAG_ARC_HAS_FINAL_OUTPUT) {\n\t\t\t\tconst finalOutputSize = new DataView(this.data.buffer).getInt32(pos);\n\t\t\t\tpos += 4;\n\t\t\t\tconst finalOutput = this.data.slice(pos, pos + finalOutputSize);\n\t\t\t\tarc.finalOutput = this.splitOutput(finalOutput);\n\t\t\t\tpos += finalOutputSize;\n\t\t\t}\n\t\t} else {\n\t\t\tarc.label = this.data[pos];\n\t\t\tpos += 1;\n\n\t\t\tif (arc.flag & FLAG_ARC_HAS_OUTPUT) {\n\t\t\t\tconst outputSize = new DataView(this.data.buffer).getInt32(pos);\n\t\t\t\tpos += 4;\n\t\t\t\tarc.output = this.data.slice(pos, pos + outputSize);\n\t\t\t\tpos += outputSize;\n\t\t\t}\n\n\t\t\tarc.target = new DataView(this.data.buffer).getInt32(pos);\n\t\t\tpos += 4;\n\t\t}\n\n\t\treturn [arc, pos - addr];\n\t}\n\n\tprivate splitOutput(output: Uint8Array): Uint8Array[] {\n\t\tconst separator = 0x1a; // ASCII SUB character\n\t\tconst result: Uint8Array[] = [];\n\t\tlet start = 0;\n\n\t\tfor (let i = 0; i < output.length; i++) {\n\t\t\tif (output[i] === separator) {\n\t\t\t\tresult.push(output.slice(start, i));\n\t\t\t\tstart = i + 1;\n\t\t\t}\n\t\t}\n\t\tif (start < output.length) {\n\t\t\tresult.push(output.slice(start));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tgetBuffer(){\n\t\treturn this.data\n\t}\n}\n\nexport function compileFST(fst: FST): Uint8Array {\n\tconst arcs: Uint8Array[] = [];\n\tconst address: { [key: number]: number } = {};\n\tlet pos = 0;\n\n\tfor (const s of Array.from(fst.dictionary.values())) {\n\t\tconst sortedTrans = Object.entries(s.transMap).sort(\n\t\t\t(a, b) => Number(b[0]) - Number(a[0]),\n\t\t);\n\n\t\tfor (let i = 0; i < sortedTrans.length; i++) {\n\t\t\tconst [c, v] = sortedTrans[i];\n\t\t\tconst buffer = new ArrayBuffer(1024);\n\t\t\tconst view = new DataView(buffer);\n\t\t\tlet offset = 0;\n\n\t\t\tlet flag = 0;\n\t\t\tif (i === 0) flag |= FLAG_LAST_ARC;\n\t\t\tif (v.output.length > 0) flag |= FLAG_ARC_HAS_OUTPUT;\n\n\t\t\tview.setInt8(offset++, flag);\n\t\t\tview.setUint8(offset++, Number(c));\n\n\t\t\tif (v.output.length > 0) {\n\t\t\t\tview.setInt32(offset, v.output.length);\n\t\t\t\toffset += 4;\n\t\t\t\tnew Uint8Array(buffer, offset).set(v.output);\n\t\t\t\toffset += v.output.length;\n\t\t\t}\n\n\t\t\tconst nextAddr = address[v.state.id!];\n\t\t\tconst target = pos + offset + 4 - nextAddr;\n\t\t\tview.setInt32(offset, target);\n\t\t\toffset += 4;\n\n\t\t\tarcs.push(new Uint8Array(buffer.slice(0, offset)));\n\t\t\tpos += offset;\n\t\t}\n\n\t\tif (s.isFinal()) {\n\t\t\tconst buffer = new ArrayBuffer(1024);\n\t\t\tconst view = new DataView(buffer);\n\t\t\tlet offset = 0;\n\n\t\t\tlet flag = FLAG_FINAL_ARC;\n\t\t\tconst finalOutputs = Array.from(s.finalOutput);\n\t\t\tconst hasOutput = finalOutputs.some((out) => out.length > 0);\n\n\t\t\tif (hasOutput) {\n\t\t\t\tflag |= FLAG_ARC_HAS_FINAL_OUTPUT;\n\t\t\t}\n\t\t\tif (!Object.keys(s.transMap).length) {\n\t\t\t\tflag |= FLAG_LAST_ARC;\n\t\t\t}\n\n\t\t\tview.setInt8(offset++, flag);\n\n\t\t\tif (hasOutput) {\n\t\t\t\tconst separator = new Uint8Array([0x1a]);\n\t\t\t\tconst totalLength =\n\t\t\t\t\tfinalOutputs.reduce((sum, curr) => sum + curr.length, 0) +\n\t\t\t\t\t(finalOutputs.length - 1);\n\n\t\t\t\tview.setInt32(offset, totalLength);\n\t\t\t\toffset += 4;\n\n\t\t\t\tfor (let i = 0; i < finalOutputs.length; i++) {\n\t\t\t\t\tnew Uint8Array(buffer, offset).set(finalOutputs[i]);\n\t\t\t\t\toffset += finalOutputs[i].length;\n\t\t\t\t\tif (i < finalOutputs.length - 1) {\n\t\t\t\t\t\tnew Uint8Array(buffer, offset).set(separator);\n\t\t\t\t\t\toffset += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tarcs.push(new Uint8Array(buffer.slice(0, offset)));\n\t\t\tpos += offset;\n\t\t}\n\t\taddress[s.id!] = pos;\n\t}\n\n\tarcs.reverse();\n\tconst totalLength = arcs.reduce((sum, arr) => sum + arr.length, 0);\n\tconst result = new Uint8Array(totalLength);\n\tlet offset = 0;\n\n\tfor (const arc of arcs) {\n\t\tresult.set(arc, offset);\n\t\toffset += arc.length;\n\t}\n\n\treturn result;\n}\n\nfunction prefixLen(s1: Uint8Array, s2: Uint8Array): number {\n\tlet i = 0;\n\twhile (i < s1.length && i < s2.length && s1[i] === s2[i]) {\n\t\ti++;\n\t}\n\treturn i;\n}\n\nfunction copyState(state: State, id: number): State {\n\tconst newState = new State(id);\n\tnewState.setFinal(state.isFinal());\n\tnewState.setStateOutput(new Set(state.stateOutput())); // Shallow copy of Set, but Uint8Arrays are immutable\n\tfor (const charCode in state.transMap) {\n\t\tif (state.transMap.hasOwnProperty(charCode)) {\n\t\t\tconst transition = state.transMap[charCode];\n\t\t\tnewState.setTransition(Number(charCode), transition.state); // Assuming state IDs are handled correctly later during minimization\n\t\t\tnewState.setOutput(Number(charCode), transition.output); // Shallow copy of Uint8Array, but they are immutable\n\t\t}\n\t}\n\treturn newState;\n}\n\n\nexport function createMinimumTransducer(inputs: internalKeyValue[]): FST {\n\tinputs.sort((a, b) => compareUint8Arrays(a.k, b.k));\n\tconst start_time = Date.now();\n\tlet last_printed = 0;\n\tconst inputs_size = inputs.length;\n\tconsole.log(`input size: ${inputs_size}`);\n\n\tconst fstDict = new FST();\n\tconst buffer: State[] = [];\n\tbuffer.push(new State()); // insert 'initial' state\n\n\t// previous word\n\tlet prev_word: Uint8Array = new Uint8Array();\n\n\tconst findMinimized = (state: State): State => {\n\t\t// if an equivalent state exists in the dictionary, use that\n\t\tconst s = fstDict.member(state);\n\t\tif (s === undefined) {\n\t\t\t// if no equivalent state exists, insert new one and return it\n\t\t\tconst newState = copyState(state, fstDict.size());\n\t\t\tfstDict.insert(newState);\n\t\t\treturn newState;\n\t\t}\n\t\treturn s;\n\t};\n\n\tlet processed = 0;\n\tlet current_word: Uint8Array | undefined;\n\tlet current_output: Uint8Array | undefined;\n\t// main loop\n\tfor (const input of inputs) {\n\t\tcurrent_word = input.k;\n\t\tcurrent_output = input.v;\n\n\t\t// console.debug('current word: ' + String.fromCharCode(...current_word));\n\t\t// console.debug('current_output: ' + String.fromCharCode(...current_output));\n\n\t\tif (compareUint8Arrays(current_word, prev_word) < 0) {\n\t\t\tthrow new Error(\"Input words must be sorted lexicographically.\");\n\t\t}\n\n\t\tconst pref_len = prefixLen(prev_word, current_word);\n\n\t\t// expand buffer to current word length\n\t\twhile (buffer.length <= current_word.length) {\n\t\t\tbuffer.push(new State());\n\t\t}\n\n\t\t// set state transitions\n\t\tfor (let i = prev_word.length; i > pref_len; i--) {\n\t\t\tbuffer[i - 1].setTransition(prev_word[i - 1], findMinimized(buffer[i]));\n\t\t}\n\t\tfor (let i = pref_len + 1; i <= current_word.length; i++) {\n\t\t\tbuffer[i].clear();\n\t\t\tbuffer[i - 1].setTransition(current_word[i - 1], buffer[i]);\n\t\t}\n\t\tif (compareUint8Arrays(current_word, prev_word) !== 0) {\n\t\t\tbuffer[current_word.length].setFinal(true);\n\t\t\tbuffer[current_word.length].setStateOutput(new Set([new Uint8Array()]));\n\t\t}\n\n\t\t// set state outputs\n\t\tfor (let j = 1; j <= pref_len; j++) {\n\t\t\t// divide (j-1)th state's output to (common) prefix and suffix\n\t\t\tconst common_prefix_arr: number[] = [];\n\t\t\tconst output = buffer[j - 1].output(current_word[j - 1]);\n\t\t\tlet k = 0;\n\t\t\twhile (k < output.length && k < current_output.length && output[k] === current_output[k]) {\n\t\t\t\tcommon_prefix_arr.push(output[k]);\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tconst common_prefix = new Uint8Array(common_prefix_arr);\n\t\t\tconst word_suffix = output.slice(common_prefix.length);\n\n\t\t\t// re-set (j-1)'th state's output to prefix\n\t\t\tbuffer[j - 1].setOutput(current_word[j - 1], common_prefix);\n\n\t\t\t// re-set jth state's output to suffix or set final state output\n\t\t\tfor (const charCodeStr in buffer[j].transMap) {\n\t\t\t\tif (buffer[j].transMap.hasOwnProperty(charCodeStr)) {\n\t\t\t\t\tconst charCode = Number(charCodeStr);\n\t\t\t\t\tconst new_output_arr = [...word_suffix, ...buffer[j].output(charCode)];\n\t\t\t\t\tconst new_output = new Uint8Array(new_output_arr);\n\t\t\t\t\tbuffer[j].setOutput(charCode, new_output);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// or, set final state output if it's a final state\n\t\t\tif (buffer[j].isFinal()) {\n\t\t\t\tconst tmp_set = new Set<Uint8Array>();\n\t\t\t\tfor (const tmp_str of buffer[j].stateOutput()) {\n\t\t\t\t\tconst newOutputArr = [...word_suffix, ...tmp_str];\n\t\t\t\t\ttmp_set.add(new Uint8Array(newOutputArr));\n\t\t\t\t}\n\t\t\t\tbuffer[j].setStateOutput(tmp_set);\n\t\t\t}\n\n\t\t\t// update current output (subtract prefix)\n\t\t\tcurrent_output = current_output.slice(common_prefix.length);\n\t\t}\n\n\t\tif (compareUint8Arrays(current_word, prev_word) === 0) {\n\t\t\tbuffer[current_word.length].stateOutput().add(current_output);\n\t\t} else {\n\t\t\tbuffer[pref_len].setOutput(current_word[pref_len], current_output);\n\t\t}\n\n\t\t// preserve current word for next loop\n\t\tprev_word = current_word;\n\n\t\t// progress\n\t\tprocessed++;\n\t\tconst elapsed = Math.round((Date.now() - start_time) / 1000);\n\t\tif (elapsed % 30 === 0 && elapsed > last_printed) {\n\t\t\tconst progress = (processed / inputs_size) * 100;\n\t\t\tconsole.log(`elapsed=${elapsed}sec, progress: ${progress} %`);\n\t\t\tlast_printed = elapsed;\n\t\t}\n\t}\n\tif (current_word){\n\t\t// minimize the last word\n\t\tfor (let i = current_word.length; i > 0; i--) {\n\t\t\tbuffer[i - 1].setTransition(prev_word[i - 1], findMinimized(buffer[i]));\n\t\t}\n\t}\n\t\n\n\tfindMinimized(buffer[0]);\n\tconsole.log(`num of state: ${fstDict.size()}`);\n\n\treturn fstDict;\n}\n\n\nfunction compareUint8Arrays(arr1: Uint8Array, arr2: Uint8Array): number {\n\tconst len1 = arr1.length;\n\tconst len2 = arr2.length;\n\tconst len = Math.min(len1, len2);\n\tfor (let i = 0; i < len; i++) {\n\t\tif (arr1[i] < arr2[i]) {\n\t\t\treturn -1;\n\t\t} else if (arr1[i] > arr2[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (len1 < len2) {\n\t\treturn -1;\n\t} else if (len1 > len2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport {\n\tState,\n\tFST,\n\tMatcher,\n\tFLAG_FINAL_ARC,\n\tFLAG_LAST_ARC,\n\tFLAG_ARC_HAS_OUTPUT,\n\tFLAG_ARC_HAS_FINAL_OUTPUT,\n};\n","import { FST, State, createMinimumTransducer } from \"./FST\";\n\ninterface KeyValue {\n\tk: string;\n\tv: number;\n}\n\nexport class FSTBuilder {\n\tprivate states: State[];\n\n\tconstructor() {\n\t\tthis.states = [];\n\t}\n\n\t/**\n\t * 新しい状態を作成します\n\t */\n\tnewState(): State {\n\t\tconst state = new State(this.states.length);\n\t\tthis.states.push(state);\n\t\treturn state;\n\t}\n\n\t/**\n\t * FSTを最適化して構築します\n\t */\n\tbuild(keys: KeyValue[]): FST {\n\t\t// Convert key string to ArrayBuffer\n\t\tconst textEncoder = new TextEncoder()\n\t\tconst buff_keys = keys.map<{ k: Uint8Array, v: Uint8Array }>((k: KeyValue) => {\n\t\t\treturn {\n\t\t\t\tk: textEncoder.encode(k.k),\n\t\t\t\tv: textEncoder.encode(k.v.toString())\n\t\t\t}\n\t\t});\n\n\t\treturn createMinimumTransducer(buff_keys);\n\t}\n}\n","// Copyright (c) 2014 Takuya Asano All Rights Reserved.\n\nimport type { WordSearch } from \"../dict/DynamicDictionaries\";\n\nconst TERM_CHAR = \"\\u0000\"; // terminal character\nconst TERM_CODE = 0; // terminal character code\nconst ROOT_ID = 0; // index of root node\nconst NOT_FOUND = -1; // traverse() returns if no nodes found\nconst BASE_SIGNED = true;\nconst CHECK_SIGNED = true;\nconst BASE_BYTES = 4;\nconst CHECK_BYTES = 4;\nconst MEMORY_EXPAND_RATIO = 2;\n\ntype Arrays =\n\t| Int8Array\n\t| Int16Array\n\t| Int32Array\n\t| Uint8Array\n\t| Uint16Array\n\t| Uint32Array;\n\ninterface BaseAndCheck {\n\tgetBaseBuffer(): Arrays; // Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array\n\tgetCheckBuffer(): Arrays; // Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array\n\tloadBaseBuffer(base_buffer: Arrays): BaseAndCheck;\n\tloadCheckBuffer(check_buffer: Arrays): BaseAndCheck;\n\tsize(): number;\n\tgetBase(index: number): number;\n\tgetCheck(index: number): number;\n\tsetBase(index: number, base_value: number): void;\n\tsetCheck(index: number, check_value: number): void;\n\tsetFirstUnusedNode(index: number): void;\n\tgetFirstUnusedNode(): number;\n\tshrink(): void;\n\tcalc(): { all: number; unused: number; efficiency: number };\n\tdump(): string;\n}\n\ninterface external_KeyValue {\n\tk: string;\n\tv: number;\n}\n\ninterface internal_KeyValue {\n\tk: Uint8Array;\n\tv: number;\n}\n\nconst newBC = (initial_size = 1024): BaseAndCheck => {\n\tconst initBase = (_base: Arrays, start: number, end: number) => {\n\t\t// 'end' index does not include\n\t\tfor (let i = start; i < end; i++) {\n\t\t\t_base[i] = -i + 1; // inversed previous empty node index\n\t\t}\n\t\tif (0 < check.array[check.array.length - 1]) {\n\t\t\tlet last_used_id = check.array.length - 2;\n\t\t\twhile (0 < check.array[last_used_id]) {\n\t\t\t\tlast_used_id--;\n\t\t\t}\n\t\t\t_base[start] = -last_used_id;\n\t\t}\n\t};\n\n\tconst initCheck = (_check: Arrays, start: number, end: number) => {\n\t\tfor (let i = start; i < end; i++) {\n\t\t\t_check[i] = -i - 1; // inversed next empty node index\n\t\t}\n\t};\n\n\tconst realloc = (min_size: number) => {\n\t\t// expand arrays size by given ratio\n\t\tconst new_size = min_size * MEMORY_EXPAND_RATIO;\n\t\t// console.log('re-allocate memory to ' + new_size);\n\n\t\tconst base_new_array = newArrayBuffer(base.signed, base.bytes, new_size);\n\t\tinitBase(base_new_array, base.array.length, new_size); // init BASE in new range\n\t\tbase_new_array.set(base.array);\n\t\tbase.array = base_new_array;\n\n\t\tconst check_new_array = newArrayBuffer(check.signed, check.bytes, new_size);\n\t\tinitCheck(check_new_array, check.array.length, new_size); // init CHECK in new range\n\t\tcheck_new_array.set(check.array);\n\t\tcheck.array = check_new_array;\n\t};\n\n\tlet first_unused_node = ROOT_ID + 1;\n\n\tconst base: {\n\t\tsigned: boolean;\n\t\tbytes: number;\n\t\tarray: Arrays;\n\t} = {\n\t\tsigned: BASE_SIGNED,\n\t\tbytes: BASE_BYTES,\n\t\tarray: newArrayBuffer(BASE_SIGNED, BASE_BYTES, initial_size),\n\t};\n\n\tconst check: {\n\t\tsigned: boolean;\n\t\tbytes: number;\n\t\tarray: Arrays;\n\t} = {\n\t\tsigned: CHECK_SIGNED,\n\t\tbytes: CHECK_BYTES,\n\t\tarray: newArrayBuffer(CHECK_SIGNED, CHECK_BYTES, initial_size),\n\t};\n\n\t// init root node\n\tbase.array[ROOT_ID] = 1;\n\tcheck.array[ROOT_ID] = ROOT_ID;\n\n\t// init BASE\n\tinitBase(base.array, ROOT_ID + 1, base.array.length);\n\n\t// init CHECK\n\tinitCheck(check.array, ROOT_ID + 1, check.array.length);\n\n\treturn {\n\t\tgetBaseBuffer: () => base.array,\n\t\tgetCheckBuffer: () => check.array,\n\t\tloadBaseBuffer: function (base_buffer: Arrays) {\n\t\t\tbase.array = base_buffer;\n\t\t\treturn this;\n\t\t},\n\t\tloadCheckBuffer: function (check_buffer: Arrays) {\n\t\t\tcheck.array = check_buffer;\n\t\t\treturn this;\n\t\t},\n\t\tsize: () => Math.max(base.array.length, check.array.length),\n\t\tgetBase: (index: number) => {\n\t\t\tif (base.array.length - 1 < index) {\n\t\t\t\treturn -index + 1;\n\t\t\t\t// realloc(index);\n\t\t\t}\n\t\t\t// if (!Number.isFinite(base.array[index])) {\n\t\t\t//     console.log('getBase:' + index);\n\t\t\t//     throw 'getBase' + index;\n\t\t\t// }\n\t\t\treturn base.array[index];\n\t\t},\n\t\tgetCheck: (index: number) => {\n\t\t\tif (check.array.length - 1 < index) {\n\t\t\t\treturn -index - 1;\n\t\t\t\t// realloc(index);\n\t\t\t}\n\t\t\t// if (!Number.isFinite(check.array[index])) {\n\t\t\t//     console.log('getCheck:' + index);\n\t\t\t//     throw 'getCheck' + index;\n\t\t\t// }\n\t\t\treturn check.array[index];\n\t\t},\n\t\tsetBase: (index: number, base_value: number) => {\n\t\t\tif (base.array.length - 1 < index) {\n\t\t\t\trealloc(index);\n\t\t\t}\n\t\t\tbase.array[index] = base_value;\n\t\t},\n\t\tsetCheck: (index: number, check_value: number) => {\n\t\t\tif (check.array.length - 1 < index) {\n\t\t\t\trealloc(index);\n\t\t\t}\n\t\t\tcheck.array[index] = check_value;\n\t\t},\n\t\tsetFirstUnusedNode: (index: number) => {\n\t\t\t// if (!Number.isFinite(index)) {\n\t\t\t//     throw 'assertion error: setFirstUnusedNode ' + index + ' is not finite number';\n\t\t\t// }\n\t\t\tfirst_unused_node = index;\n\t\t},\n\t\tgetFirstUnusedNode: () => {\n\t\t\t// if (!Number.isFinite(first_unused_node)) {\n\t\t\t//     throw 'assertion error: getFirstUnusedNode ' + first_unused_node + ' is not finite number';\n\t\t\t// }\n\t\t\treturn first_unused_node;\n\t\t},\n\t\tshrink: function () {\n\t\t\tlet last_index = this.size() - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (0 <= check.array[last_index]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlast_index--;\n\t\t\t}\n\t\t\tbase.array = base.array.subarray(0, last_index + 2); // keep last unused node\n\t\t\tcheck.array = check.array.subarray(0, last_index + 2); // keep last unused node\n\t\t},\n\t\tcalc: () => {\n\t\t\tlet unused_count = 0;\n\t\t\tconst size = check.array.length;\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tif (check.array[i] < 0) {\n\t\t\t\t\tunused_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tall: size,\n\t\t\t\tunused: unused_count,\n\t\t\t\tefficiency: (size - unused_count) / size,\n\t\t\t};\n\t\t},\n\t\tdump: function () {\n\t\t\t// for debug\n\t\t\tlet dump_base = \"\";\n\t\t\tlet dump_check = \"\";\n\n\t\t\tlet i: number;\n\t\t\tfor (i = 0; i < base.array.length; i++) {\n\t\t\t\tdump_base = `${dump_base} ${this.getBase(i)}`;\n\t\t\t}\n\t\t\tfor (i = 0; i < check.array.length; i++) {\n\t\t\t\tdump_check = `${dump_check} ${this.getCheck(i)}`;\n\t\t\t}\n\n\t\t\tconsole.log(`base:${dump_base}`);\n\t\t\tconsole.log(`chck:${dump_check}`);\n\n\t\t\treturn `base:${dump_base} chck:${dump_check}`;\n\t\t},\n\t};\n};\n\n/**\n * Factory method of double array\n */\nexport default class DoubleArrayBuilder {\n\tbc: BaseAndCheck;\n\tkeys: (external_KeyValue | internal_KeyValue)[];\n\tconstructor(initial_size?: number ) {\n\t\tthis.bc = newBC(initial_size); // BASE and CHECK\n\t\tthis.keys = [];\n\t}\n\t/**\n\t * Append a key to initialize set\n\t * (This method should be called by dictionary ordered key)\n\t *\n\t * @param {String} key\n\t * @param {Number} record Integer value from 0 to max signed integer number - 1\n\t */\n\tappend(key: string, record: number) {\n\t\tthis.keys.push({ k: key, v: record } as external_KeyValue);\n\t\treturn this;\n\t}\n\t/**\n\t * Build double array for given keys\n\t *\n\t * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\n\t * 'k' is a key string, 'v' is a record assigned to that key.\n\t * @return {DoubleArray} Compiled double array\n\t */\n\tbuild(keys: external_KeyValue[] = this.keys as external_KeyValue[], sorted = false): DoubleArray {\n\t\tif (keys == null) {\n\t\t\treturn new DoubleArray(this.bc);\n\t\t}\n\n\t\t// Convert key string to ArrayBuffer\n\t\tconst buff_keys: internal_KeyValue[] = keys.map((k: external_KeyValue) => {\n\t\t\treturn {\n\t\t\t\tk: stringToUtf8Bytes(k.k + TERM_CHAR),\n\t\t\t\tv: k.v,\n\t\t\t};\n\t\t});\n\n\t\t// Sort keys by byte order\n\t\tif (sorted) {\n\t\t\tthis.keys = buff_keys;\n\t\t} else {\n\t\t\tthis.keys = buff_keys.sort((k1: { k: any }, k2: { k: any }) => {\n\t\t\t\tconst b1 = k1.k;\n\t\t\t\tconst b2 = k2.k;\n\t\t\t\tconst min_length = Math.min(b1.length, b2.length);\n\t\t\t\tfor (let pos = 0; pos < min_length; pos++) {\n\t\t\t\t\tif (b1[pos] === b2[pos]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn b1[pos] - b2[pos];\n\t\t\t\t}\n\t\t\t\treturn b1.length - b2.length;\n\t\t\t});\n\t\t}\n\t\tthis._build(ROOT_ID, 0, 0, this.keys.length);\n\t\treturn new DoubleArray(this.bc);\n\t}\n\t/**\n\t * Append nodes to BASE and CHECK array recursively\n\t */\n\t_build(\n\t\tparent_index: number,\n\t\tposition: number,\n\t\tstart: number,\n\t\tlength: number,\n\t) {\n\t\tconst children_info = this.getChildrenInfo(position, start, length);\n\t\tconst _base = this.findAllocatableBase(children_info);\n\n\t\tthis.setBC(parent_index, children_info, _base);\n\n\t\tfor (let i = 0; i < children_info.length; i = i + 3) {\n\t\t\tconst child_code = children_info[i];\n\t\t\tif (child_code === TERM_CODE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst child_start = children_info[i + 1];\n\t\t\tconst child_len = children_info[i + 2];\n\t\t\tconst child_index = _base + child_code;\n\t\t\tthis._build(child_index, position + 1, child_start, child_len);\n\t\t}\n\t}\n\tgetChildrenInfo(position: number, start: number, length: number) {\n\t\tlet current_char = this.keys[start].k[position] as number;\n\t\tlet i = 0;\n\t\tlet children_info = new Int32Array(length * 3);\n\n\t\tchildren_info[i++] = current_char; // char (current)\n\t\tchildren_info[i++] = start; // start index (current)\n\n\t\tlet next_pos = start;\n\t\tlet start_pos = start;\n\t\tfor (; next_pos < start + length; next_pos++) {\n\t\t\tconst next_char = this.keys[next_pos].k[position] as number;\n\t\t\tif (current_char !== next_char) {\n\t\t\t\tchildren_info[i++] = next_pos - start_pos; // length (current)\n\n\t\t\t\tchildren_info[i++] = next_char; // char (next)\n\t\t\t\tchildren_info[i++] = next_pos; // start index (next)\n\t\t\t\tcurrent_char = next_char;\n\t\t\t\tstart_pos = next_pos;\n\t\t\t}\n\t\t}\n\t\tchildren_info[i++] = next_pos - start_pos;\n\t\tchildren_info = children_info.subarray(0, i);\n\n\t\treturn children_info;\n\t}\n\tsetBC(parent_id: number, children_info: Int32Array, _base: number) {\n\t\tconst bc = this.bc;\n\n\t\tbc.setBase(parent_id, _base); // Update BASE of parent node\n\n\t\tlet i: number;\n\t\tfor (i = 0; i < children_info.length; i = i + 3) {\n\t\t\tconst code = children_info[i];\n\t\t\tconst child_id = _base + code;\n\n\t\t\t// Update linked list of unused nodes\n\t\t\t// Assertion\n\t\t\t// if (child_id < 0) {\n\t\t\t//     throw 'assertion error: child_id is negative'\n\t\t\t// }\n\t\t\tconst prev_unused_id = -bc.getBase(child_id);\n\t\t\tconst next_unused_id = -bc.getCheck(child_id);\n\t\t\t// if (prev_unused_id < 0) {\n\t\t\t//     throw 'assertion error: setBC'\n\t\t\t// }\n\t\t\t// if (next_unused_id < 0) {\n\t\t\t//     throw 'assertion error: setBC'\n\t\t\t// }\n\t\t\tif (child_id !== bc.getFirstUnusedNode()) {\n\t\t\t\tbc.setCheck(prev_unused_id, -next_unused_id);\n\t\t\t} else {\n\t\t\t\t// Update first_unused_node\n\t\t\t\tbc.setFirstUnusedNode(next_unused_id);\n\t\t\t}\n\t\t\tbc.setBase(next_unused_id, -prev_unused_id);\n\n\t\t\tconst check = parent_id; // CHECK is parent node index\n\t\t\tbc.setCheck(child_id, check); // Update CHECK of child node\n\n\t\t\t// Update record\n\t\t\tif (code === TERM_CODE) {\n\t\t\t\tconst start_pos = children_info[i + 1];\n\t\t\t\t// var len = children_info[i + 2];\n\t\t\t\t// if (len != 1) {\n\t\t\t\t//     throw 'assertion error: there are multiple terminal nodes. len:' + len;\n\t\t\t\t// }\n\t\t\t\tlet value = this.keys[start_pos].v;\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\n\t\t\t\tconst base = -value - 1; // BASE is inverted record value\n\t\t\t\tbc.setBase(child_id, base); // Update BASE of child(leaf) node\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Find BASE value that all children are allocatable in double array's region\n\t */\n\tfindAllocatableBase(children_info: Int32Array) {\n\t\tconst bc = this.bc;\n\n\t\t// Assertion: keys are sorted by byte order\n\t\t// var c = -1;\n\t\t// for (var i = 0; i < children_info.length; i = i + 3) {\n\t\t//     if (children_info[i] < c) {\n\t\t//         throw 'assertion error: not sort key'\n\t\t//     }\n\t\t//     c = children_info[i];\n\t\t// }\n\t\t// iterate linked list of unused nodes\n\t\tlet _base: number;\n\t\tlet curr = bc.getFirstUnusedNode(); // current index\n\n\t\t// if (curr < 0) {\n\t\t//     throw 'assertion error: getFirstUnusedNode returns negative value'\n\t\t// }\n\t\twhile (true) {\n\t\t\t_base = curr - children_info[0];\n\n\t\t\tif (_base < 0) {\n\t\t\t\tcurr = -bc.getCheck(curr); // next\n\n\t\t\t\t// if (curr < 0) {\n\t\t\t\t//     throw 'assertion error: getCheck returns negative value'\n\t\t\t\t// }\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet empty_area_found = true;\n\t\t\tfor (let i = 0; i < children_info.length; i = i + 3) {\n\t\t\t\tconst code = children_info[i];\n\t\t\t\tconst candidate_id = _base + code;\n\n\t\t\t\tif (!this.isUnusedNode(candidate_id)) {\n\t\t\t\t\t// candidate_id is used node\n\t\t\t\t\t// next\n\t\t\t\t\tcurr = -bc.getCheck(curr);\n\t\t\t\t\t// if (curr < 0) {\n\t\t\t\t\t//     throw 'assertion error: getCheck returns negative value'\n\t\t\t\t\t// }\n\t\t\t\t\tempty_area_found = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (empty_area_found) {\n\t\t\t\t// Area is free\n\t\t\t\treturn _base;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Check this double array index is unused or not\n\t */\n\tisUnusedNode(index: number) {\n\t\tconst bc = this.bc;\n\t\tconst check = bc.getCheck(index);\n\n\t\t// if (index < 0) {\n\t\t//     throw 'assertion error: isUnusedNode index:' + index;\n\t\t// }\n\t\tif (index === ROOT_ID) {\n\t\t\t// root node\n\t\t\treturn false;\n\t\t}\n\t\tif (check < 0) {\n\t\t\t// unused\n\t\t\treturn true;\n\t\t}\n\n\t\t// used node (incl. leaf)\n\t\treturn false;\n\t}\n}\n\n/**\n * Factory method of double array\n */\nexport class DoubleArray implements WordSearch {\n\tbc: BaseAndCheck;\n\tconstructor(bc: BaseAndCheck) {\n\t\tthis.bc = bc; // BASE and CHECK\n\t\tthis.bc.shrink();\n\t}\n\t/**\n\t * Look up a given key in this trie\n\t *\n\t * @param {String} key\n\t * @return {Boolean} True if this trie contains a given key\n\t */\n\tcontain(key: string): boolean {\n\t\tconst bc = this.bc;\n\n\t\tkey += TERM_CHAR;\n\t\tconst buffer = stringToUtf8Bytes(key);\n\n\t\tlet parent = ROOT_ID;\n\t\tlet child = NOT_FOUND;\n\n\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\tconst code = buffer[i];\n\n\t\t\tchild = this.traverse(parent, code);\n\t\t\tif (child === NOT_FOUND) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (bc.getBase(child) <= 0) {\n\t\t\t\t// leaf node\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// not leaf\n\t\t\tparent = child;\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Look up a given key in this trie\n\t *\n\t * @param {String} key\n\t * @return {Number} Record value assgned to this key, -1 if this key does not contain\n\t */\n\tlookup(key: string): number {\n\t\tkey += TERM_CHAR;\n\t\tconst buffer = stringToUtf8Bytes(key);\n\n\t\tlet parent = ROOT_ID;\n\t\tlet child = NOT_FOUND;\n\n\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\tconst code = buffer[i];\n\t\t\tchild = this.traverse(parent, code);\n\t\t\tif (child === NOT_FOUND) {\n\t\t\t\treturn NOT_FOUND;\n\t\t\t}\n\t\t\tparent = child;\n\t\t}\n\n\t\tconst base = this.bc.getBase(child);\n\t\tif (base <= 0) {\n\t\t\t// leaf node\n\t\t\treturn -base - 1;\n\t\t}\n\t\t// not leaf\n\t\treturn NOT_FOUND;\n\t}\n\t/**\n\t * Common prefix search\n\t *\n\t * @param {String} key\n\t * @return {Array} Each result object has 'k' and 'v' (key and record,\n\t * respectively) properties assigned to matched string\n\t */\n\tcommonPrefixSearch(key: string): external_KeyValue[] {\n\t\tconst buffer = stringToUtf8Bytes(key);\n\n\t\tlet parent = ROOT_ID;\n\t\tlet child = NOT_FOUND;\n\n\t\tconst result: external_KeyValue[] = [];\n\n\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\tconst code = buffer[i];\n\n\t\t\tchild = this.traverse(parent, code);\n\n\t\t\tif (child !== NOT_FOUND) {\n\t\t\t\tparent = child;\n\n\t\t\t\t// look forward by terminal character code to check this node is a leaf or not\n\t\t\t\tconst grand_child = this.traverse(child, TERM_CODE);\n\n\t\t\t\tif (grand_child !== NOT_FOUND) {\n\t\t\t\t\tconst base = this.bc.getBase(grand_child);\n\n\t\t\t\t\tconst r: external_KeyValue = {\n\t\t\t\t\t\tk: \"\",\n\t\t\t\t\t\tv: 0,\n\t\t\t\t\t};\n\n\t\t\t\t\tif (base <= 0) {\n\t\t\t\t\t\t// If child is a leaf node, add record to result\n\t\t\t\t\t\tr.v = -base - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If child is a leaf node, add word to result\n\t\t\t\t\tr.k = utf8BytesToString(arrayCopy(buffer, 0, i + 1));\n\n\t\t\t\t\tresult.push(r);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\ttraverse(parent: number, code: number) {\n\t\tconst child = this.bc.getBase(parent) + code;\n\t\tif (this.bc.getCheck(child) === parent) {\n\t\t\treturn child;\n\t\t}\n\t\treturn NOT_FOUND;\n\t}\n\tsize() {\n\t\treturn this.bc.size();\n\t}\n\tcalc() {\n\t\treturn this.bc.calc();\n\t}\n\tdump() {\n\t\treturn this.bc.dump();\n\t}\n}\n\n// Array utility functions\n\nconst newArrayBuffer = (signed: boolean, bytes: number, size: number) => {\n\tif (signed) {\n\t\tswitch (bytes) {\n\t\t\tcase 1:\n\t\t\t\treturn new Int8Array(size);\n\t\t\tcase 2:\n\t\t\t\treturn new Int16Array(size);\n\t\t\tcase 4:\n\t\t\t\treturn new Int32Array(size);\n\t\t\tdefault:\n\t\t\t\tthrow new RangeError(\n\t\t\t\t\t`Invalid newArray parameter element_bytes:${bytes}`,\n\t\t\t\t);\n\t\t}\n\t}\n\tswitch (bytes) {\n\t\tcase 1:\n\t\t\treturn new Uint8Array(size);\n\t\tcase 2:\n\t\t\treturn new Uint16Array(size);\n\t\tcase 4:\n\t\t\treturn new Uint32Array(size);\n\t\tdefault:\n\t\t\tthrow new RangeError(`Invalid newArray parameter element_bytes:${bytes}`);\n\t}\n};\n\nconst arrayCopy = (src: Uint8Array, src_offset: number, length: number) => {\n\tconst buffer = new ArrayBuffer(length);\n\tconst dstU8 = new Uint8Array(buffer, 0, length);\n\tconst srcU8 = src.subarray(src_offset, length);\n\tdstU8.set(srcU8);\n\treturn dstU8;\n};\n\n/**\n * Convert String (UTF-16) to UTF-8 ArrayBuffer\n *\n * @param {String} str UTF-16 string to convert\n * @return {Uint8Array} Byte sequence encoded by UTF-8\n */\nconst stringToUtf8Bytes = (str: string): Uint8Array => {\n\t// Max size of 1 character is 4 bytes\n\tconst bytes = new Uint8Array(new ArrayBuffer(str.length * 4));\n\n\tlet i = 0;\n\tlet j = 0;\n\n\twhile (i < str.length) {\n\t\tlet unicode_code: number;\n\n\t\tconst utf16_code = str.charCodeAt(i++);\n\t\tif (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n\t\t\t// surrogate pair\n\t\t\tconst upper = utf16_code; // high surrogate\n\t\t\tconst lower = str.charCodeAt(i++); // low surrogate\n\n\t\t\tif (lower >= 0xdc00 && lower <= 0xdfff) {\n\t\t\t\tunicode_code =\n\t\t\t\t\t(upper - 0xd800) * (1 << 10) + (1 << 16) + (lower - 0xdc00);\n\t\t\t} else {\n\t\t\t\t// malformed surrogate pair\n\t\t\t\tthrow new Error(\"malformed surrogate pair\");\n\t\t\t}\n\t\t} else {\n\t\t\t// not surrogate code\n\t\t\tunicode_code = utf16_code;\n\t\t}\n\n\t\tif (unicode_code < 0x80) {\n\t\t\t// 1-byte\n\t\t\tbytes[j++] = unicode_code;\n\t\t} else if (unicode_code < 1 << 11) {\n\t\t\t// 2-byte\n\t\t\tbytes[j++] = (unicode_code >>> 6) | 0xc0;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 16) {\n\t\t\t// 3-byte\n\t\t\tbytes[j++] = (unicode_code >>> 12) | 0xe0;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 21) {\n\t\t\t// 4-byte\n\t\t\tbytes[j++] = (unicode_code >>> 18) | 0xf0;\n\t\t\tbytes[j++] = ((unicode_code >> 12) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else {\n\t\t\t// malformed UCS4 code\n\t\t}\n\t}\n\n\treturn bytes.subarray(0, j);\n};\n\n/**\n * Convert UTF-8 ArrayBuffer to String (UTF-16)\n *\n * @param {Uint8Array} bytes UTF-8 byte sequence to convert\n * @return {String} String encoded by UTF-16\n */\nconst utf8BytesToString = (bytes: Uint8Array): string => {\n\tlet str = \"\";\n\tlet code: number;\n\tlet b1: number;\n\tlet b2: number;\n\tlet b3: number;\n\tlet b4: number;\n\tlet upper: number;\n\tlet lower: number;\n\tlet i = 0;\n\n\twhile (i < bytes.length) {\n\t\tb1 = bytes[i++];\n\n\t\tif (b1 < 0x80) {\n\t\t\t// 1 byte\n\t\t\tcode = b1;\n\t\t} else if (b1 >> 5 === 0x06) {\n\t\t\t// 2 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tcode = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\n\t\t} else if (b1 >> 4 === 0x0e) {\n\t\t\t// 3 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tcode = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\n\t\t} else {\n\t\t\t// 4 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tb4 = bytes[i++];\n\t\t\tcode =\n\t\t\t\t((b1 & 0x07) << 18) |\n\t\t\t\t((b2 & 0x3f) << 12) |\n\t\t\t\t((b3 & 0x3f) << 6) |\n\t\t\t\t(b4 & 0x3f);\n\t\t}\n\n\t\tif (code < 0x10000) {\n\t\t\tstr += String.fromCharCode(code);\n\t\t} else {\n\t\t\t// surrogate pair\n\t\t\tcode -= 0x10000;\n\t\t\tupper = 0xd800 | (code >> 10);\n\t\t\tlower = 0xdc00 | (code & 0x3ff);\n\t\t\tstr += String.fromCharCode(upper, lower);\n\t\t}\n\t}\n\n\treturn str;\n};\n\n// public methods\nexport function builder(initial_size?: number): DoubleArrayBuilder {\n\treturn new DoubleArrayBuilder(initial_size);\n}\nexport function load(base_buffer: Arrays, check_buffer: Arrays) {\n\tconst bc = newBC(0);\n\tbc.loadBaseBuffer(base_buffer);\n\tbc.loadCheckBuffer(check_buffer);\n\treturn new DoubleArray(bc);\n}\n","import { Matcher } from \"../fst/FST\";\nimport { builder, load } from \"../util/DoubleArray\";\nimport ConnectionCosts from \"./ConnectionCosts\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\nimport UnknownDictionary from \"./UnknownDictionary\";\n\ninterface KeyValue {\n\tk: string;\n\tv: number;\n}\n\nexport interface WordSearch {\n\tcommonPrefixSearch(word: string): KeyValue[];\n\tlookup(key: string): number\n}\n\n/**\n * Dictionaries container for Tokenizer\n * @param {DoubleArray} trie\n * @param {TokenInfoDictionary} token_info_dictionary\n * @param {ConnectionCosts} connection_costs\n * @param {UnknownDictionary} unknown_dictionary\n * @constructor\n */\nclass DynamicDictionaries {\n\tword: WordSearch;\n\ttoken_info_dictionary: TokenInfoDictionary;\n\tconnection_costs: ConnectionCosts;\n\tunknown_dictionary: UnknownDictionary;\n\n\tconstructor(\n\t\tword?: WordSearch,\n\t\ttoken_info_dictionary?: TokenInfoDictionary,\n\t\tconnection_costs?: ConnectionCosts,\n\t\tunknown_dictionary?: UnknownDictionary,\n\t) {\n\t\tif (word != null) {\n\t\t\tthis.word = word;\n\t\t} else {\n\t\t\tthis.word = builder(0).build([{ k: \"\", v: 1 }]);\n\t\t}\n\t\tif (token_info_dictionary != null) {\n\t\t\tthis.token_info_dictionary = token_info_dictionary;\n\t\t} else {\n\t\t\tthis.token_info_dictionary = new TokenInfoDictionary();\n\t\t}\n\t\tif (connection_costs != null) {\n\t\t\tthis.connection_costs = connection_costs;\n\t\t} else {\n\t\t\t// backward_size * backward_size\n\t\t\tthis.connection_costs = new ConnectionCosts(0, 0);\n\t\t}\n\t\tif (unknown_dictionary != null) {\n\t\t\tthis.unknown_dictionary = unknown_dictionary;\n\t\t} else {\n\t\t\tthis.unknown_dictionary = new UnknownDictionary();\n\t\t}\n\t}\n\t// from base.dat & check.dat\n\tloadTrie(\n\t\tbase_buffer:\n\t\t\t| Int8Array<ArrayBufferLike>\n\t\t\t| Int16Array<ArrayBufferLike>\n\t\t\t| Int32Array<ArrayBufferLike>\n\t\t\t| Uint8Array<ArrayBufferLike>\n\t\t\t| Uint16Array<ArrayBufferLike>\n\t\t\t| Uint32Array<ArrayBufferLike>,\n\t\tcheck_buffer:\n\t\t\t| Int8Array<ArrayBufferLike>\n\t\t\t| Int16Array<ArrayBufferLike>\n\t\t\t| Int32Array<ArrayBufferLike>\n\t\t\t| Uint8Array<ArrayBufferLike>\n\t\t\t| Uint16Array<ArrayBufferLike>\n\t\t\t| Uint32Array<ArrayBufferLike>,\n\t) {\n\t\tthis.word = load(base_buffer, check_buffer);\n\t\treturn this;\n\t}\n\t// from base.dat\n\tloadFST(base_buffer: Uint8Array) {\n\t\tthis.word = new Matcher(base_buffer);\n\t\treturn this;\n\t}\n\tloadTokenInfoDictionaries(\n\t\ttoken_info_buffer: Uint8Array<ArrayBufferLike> | undefined,\n\t\tpos_buffer: Uint8Array<ArrayBufferLike> | undefined,\n\t\ttarget_map_buffer: Uint8Array<ArrayBufferLike> | undefined,\n\t) {\n\t\tthis.token_info_dictionary.loadDictionary(token_info_buffer);\n\t\tthis.token_info_dictionary.loadPosVector(pos_buffer);\n\t\tthis.token_info_dictionary.loadTargetMap(target_map_buffer);\n\t\treturn this;\n\t}\n\tloadConnectionCosts(cc_buffer: Int16Array<ArrayBuffer>) {\n\t\tthis.connection_costs.loadConnectionCosts(cc_buffer);\n\t\treturn this;\n\t}\n\tloadUnknownDictionaries(\n\t\tunk_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_pos_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_map_buffer: Uint8Array<ArrayBufferLike>,\n\t\tcat_map_buffer: Uint8Array,\n\t\tcompat_cat_map_buffer: Uint32Array,\n\t\tinvoke_def_buffer: Uint8Array,\n\t) {\n\t\tthis.unknown_dictionary.loadUnknownDictionaries(\n\t\t\tunk_buffer,\n\t\t\tunk_pos_buffer,\n\t\t\tunk_map_buffer,\n\t\t\tcat_map_buffer,\n\t\t\tcompat_cat_map_buffer,\n\t\t\tinvoke_def_buffer,\n\t\t);\n\t\treturn this;\n\t}\n}\n\nexport default DynamicDictionaries;\n","/**\n * Connection costs matrix from cc.dat file.\n * 2 dimension matrix [forward_id][backward_id] -> cost\n * @constructor\n * @param {number} forward_dimension\n * @param {number} backward_dimension\n */\nclass ConnectionCosts {\n\tbuffer: Int16Array;\n\tforward_dimension: number;\n\tbackward_dimension: number;\n\n\tconstructor(forward_dimension: number, backward_dimension: number) {\n\t\tthis.forward_dimension = forward_dimension;\n\t\tthis.backward_dimension = backward_dimension;\n\n\t\t// leading 2 integers for forward_dimension, backward_dimension, respectively\n\t\tthis.buffer = new Int16Array(forward_dimension * backward_dimension + 2);\n\t\tthis.buffer[0] = forward_dimension;\n\t\tthis.buffer[1] = backward_dimension;\n\t}\n\tput(forward_id: number, backward_id: number, cost: number) {\n\t\tconst index = forward_id * this.backward_dimension + backward_id + 2;\n\t\tif (this.buffer.length < index + 1) {\n\t\t\tthrow \"ConnectionCosts buffer overflow\";\n\t\t}\n\t\tthis.buffer[index] = cost;\n\t}\n\tget(forward_id: number, backward_id: number) {\n\t\tconst index = forward_id * this.backward_dimension + backward_id + 2;\n\t\tif (this.buffer.length < index + 1) {\n\t\t\tthrow \"ConnectionCosts buffer overflow\";\n\t\t}\n\t\treturn this.buffer[index];\n\t}\n\tloadConnectionCosts(connection_costs_buffer: Int16Array) {\n\t\tthis.forward_dimension = connection_costs_buffer[0];\n\t\tthis.backward_dimension = connection_costs_buffer[1];\n\t\tthis.buffer = connection_costs_buffer;\n\t}\n}\n\nexport default ConnectionCosts;\n","import ByteBuffer from \"../util/ByteBuffer\";\n\n/**\n * TokenInfoDictionary\n * @constructor\n */\nclass TokenInfoDictionary {\n\tdictionary: ByteBuffer;\n\ttarget_map: {\n\t\t[x: string]: (number | string)[];\n\t};\n\tpos_buffer: ByteBuffer;\n\n\tconstructor() {\n\t\tthis.dictionary = new ByteBuffer(10 * 1024 * 1024);\n\t\tthis.target_map = {}; // trie_id (of surface form) -> token_info_id (of token)\n\t\tthis.pos_buffer = new ByteBuffer(10 * 1024 * 1024);\n\t}\n\t// left_id right_id word_cost ...\n\t// ^ this position is token_info_id\n\tbuildDictionary(entries: string[][]) {\n\t\tconst dictionary_entries: { [x: number]: string } = {}; // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\n\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\tconst entry = entries[i];\n\n\t\t\tif (entry.length < 4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst surface_form = entry[0];\n\t\t\tconst left_id = Number(entry[1]);\n\t\t\tconst right_id = Number(entry[2]);\n\t\t\tconst word_cost = Number(entry[3]);\n\t\t\tconst feature = entry.slice(4).join(\",\"); // TODO Optimize\n\n\t\t\t// Assertion\n\t\t\tif (\n\t\t\t\t!Number.isFinite(left_id) ||\n\t\t\t\t!Number.isFinite(right_id) ||\n\t\t\t\t!Number.isFinite(word_cost)\n\t\t\t) {\n\t\t\t\tconsole.log(entry);\n\t\t\t}\n\n\t\t\tconst token_info_id = this.put(\n\t\t\t\tleft_id,\n\t\t\t\tright_id,\n\t\t\t\tword_cost,\n\t\t\t\tsurface_form,\n\t\t\t\tfeature,\n\t\t\t);\n\t\t\tdictionary_entries[token_info_id] = surface_form;\n\t\t}\n\n\t\t// Remove last unused area\n\t\tthis.dictionary.shrink();\n\t\tthis.pos_buffer.shrink();\n\n\t\treturn dictionary_entries;\n\t}\n\tput(\n\t\tleft_id: number,\n\t\tright_id: number,\n\t\tword_cost: number,\n\t\tsurface_form: string,\n\t\tfeature: string,\n\t) {\n\t\tconst token_info_id = this.dictionary.position;\n\t\tconst pos_id = this.pos_buffer.position;\n\n\t\tthis.dictionary.putShort(left_id);\n\t\tthis.dictionary.putShort(right_id);\n\t\tthis.dictionary.putShort(word_cost);\n\t\tthis.dictionary.putInt(pos_id);\n\t\tthis.pos_buffer.putString(`${surface_form},${feature}`);\n\n\t\treturn token_info_id;\n\t}\n\taddMapping(source: number, target: number | string) {\n\t\tlet mapping = this.target_map[source];\n\t\tif (mapping == null) {\n\t\t\tmapping = [];\n\t\t}\n\t\tmapping.push(target);\n\n\t\tthis.target_map[source] = mapping;\n\t}\n\ttargetMapToBuffer() {\n\t\tconst buffer = new ByteBuffer();\n\t\tconst map_keys_size = Object.keys(this.target_map).length;\n\t\tbuffer.putInt(map_keys_size);\n\t\tfor (const key in this.target_map) {\n\t\t\tconst values = this.target_map[key]; // Array\n\t\t\tconst map_values_size = values.length;\n\t\t\tbuffer.putInt(Number.parseInt(key));\n\t\t\tbuffer.putInt(map_values_size);\n\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\tbuffer.putInt(values[i]);\n\t\t\t}\n\t\t}\n\t\treturn buffer.shrink(); // Shrink-ed Typed Array\n\t}\n\t// from tid.dat\n\tloadDictionary(array_buffer?: Uint8Array<ArrayBufferLike>) {\n\t\tthis.dictionary = new ByteBuffer(array_buffer);\n\t\treturn this;\n\t}\n\t// from tid_pos.dat\n\tloadPosVector(array_buffer?: Uint8Array<ArrayBufferLike>) {\n\t\tthis.pos_buffer = new ByteBuffer(array_buffer);\n\t\treturn this;\n\t}\n\t// from tid_map.dat\n\tloadTargetMap(array_buffer?: Uint8Array<ArrayBufferLike>) {\n\t\tconst buffer = new ByteBuffer(array_buffer);\n\t\tbuffer.position = 0;\n\t\tthis.target_map = {};\n\t\tbuffer.readInt(); // map_keys_size\n\t\twhile (true) {\n\t\t\tif (buffer.buffer.length < buffer.position + 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst key = buffer.readInt();\n\t\t\tconst map_values_size = buffer.readInt();\n\t\t\tfor (let i = 0; i < map_values_size; i++) {\n\t\t\t\tconst value = buffer.readInt();\n\t\t\t\tthis.addMapping(key, value);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Look up features in the dictionary\n\t * @param {string} token_info_id_str Word ID to look up\n\t * @returns {string} Features string concatenated by \",\"\n\t */\n\tgetFeatures(token_info_id_str: string): string {\n\t\tconst token_info_id = Number.parseInt(token_info_id_str);\n\t\tif (Number.isNaN(token_info_id)) {\n\t\t\t// TODO throw error\n\t\t\treturn \"\";\n\t\t}\n\t\tconst pos_id = this.dictionary.getInt(token_info_id + 6);\n\t\treturn this.pos_buffer.getString(pos_id);\n\t}\n}\n\nexport default TokenInfoDictionary;\n","/**\n * Convert String (UTF-16) to UTF-8 ArrayBuffer\n *\n * @param {String} str UTF-16 string to convert\n * @return {Uint8Array} Byte sequence encoded by UTF-8\n */\nconst stringToUtf8Bytes = (str: string): Uint8Array => {\n\t// Max size of 1 character is 4 bytes\n\tconst bytes = new Uint8Array(str.length * 4);\n\n\tlet i = 0;\n\tlet j = 0;\n\n\twhile (i < str.length) {\n\t\tlet unicode_code: number;\n\n\t\tconst utf16_code = str.charCodeAt(i++);\n\t\tif (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n\t\t\t// surrogate pair\n\t\t\tconst upper = utf16_code; // high surrogate\n\t\t\tconst lower = str.charCodeAt(i++); // low surrogate\n\n\t\t\tif (lower >= 0xdc00 && lower <= 0xdfff) {\n\t\t\t\tunicode_code =\n\t\t\t\t\t(upper - 0xd800) * (1 << 10) + (1 << 16) + (lower - 0xdc00);\n\t\t\t} else {\n\t\t\t\t// malformed surrogate pair\n\t\t\t\tthrow new Error(\"malformed surrogate pair\");\n\t\t\t}\n\t\t} else {\n\t\t\t// not surrogate code\n\t\t\tunicode_code = utf16_code;\n\t\t}\n\n\t\tif (unicode_code < 0x80) {\n\t\t\t// 1-byte\n\t\t\tbytes[j++] = unicode_code;\n\t\t} else if (unicode_code < 1 << 11) {\n\t\t\t// 2-byte\n\t\t\tbytes[j++] = (unicode_code >>> 6) | 0xc0;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 16) {\n\t\t\t// 3-byte\n\t\t\tbytes[j++] = (unicode_code >>> 12) | 0xe0;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 21) {\n\t\t\t// 4-byte\n\t\t\tbytes[j++] = (unicode_code >>> 18) | 0xf0;\n\t\t\tbytes[j++] = ((unicode_code >> 12) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else {\n\t\t\t// malformed UCS4 code\n\t\t}\n\t}\n\n\treturn bytes.subarray(0, j);\n};\n\n/**\n * Convert UTF-8 ArrayBuffer to String (UTF-16)\n *\n * @param {Array} bytes UTF-8 byte sequence to convert\n * @return {String} String encoded by UTF-16\n */\nconst utf8BytesToString = (bytes: number[]): string => {\n\tlet str = \"\";\n\tlet code: number;\n\tlet b1: number;\n\tlet b2: number;\n\tlet b3: number;\n\tlet b4: number;\n\tlet upper: number;\n\tlet lower: number;\n\tlet i = 0;\n\n\twhile (i < bytes.length) {\n\t\tb1 = bytes[i++];\n\n\t\tif (b1 < 0x80) {\n\t\t\t// 1 byte\n\t\t\tcode = b1;\n\t\t} else if (b1 >> 5 === 0x06) {\n\t\t\t// 2 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tcode = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\n\t\t} else if (b1 >> 4 === 0x0e) {\n\t\t\t// 3 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tcode = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\n\t\t} else {\n\t\t\t// 4 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tb4 = bytes[i++];\n\t\t\tcode =\n\t\t\t\t((b1 & 0x07) << 18) |\n\t\t\t\t((b2 & 0x3f) << 12) |\n\t\t\t\t((b3 & 0x3f) << 6) |\n\t\t\t\t(b4 & 0x3f);\n\t\t}\n\n\t\tif (code < 0x10000) {\n\t\t\tstr += String.fromCharCode(code);\n\t\t} else {\n\t\t\t// surrogate pair\n\t\t\tcode -= 0x10000;\n\t\t\tupper = 0xd800 | (code >> 10);\n\t\t\tlower = 0xdc00 | (code & 0x3ff);\n\t\t\tstr += String.fromCharCode(upper, lower);\n\t\t}\n\t}\n\n\treturn str;\n};\n\n/**\n * Utilities to manipulate byte sequence\n * @param {(number|Uint8Array)} arg Initial size of this buffer (number), or buffer to set (Uint8Array)\n * @constructor\n */\nclass ByteBuffer {\n\tbuffer: Uint8Array<ArrayBufferLike>;\n\tposition: number;\n\tconstructor(arg?: number | Uint8Array) {\n\t\tlet initial_size: number;\n\t\tif (arg == null) {\n\t\t\tinitial_size = 1024 * 1024;\n\t\t} else if (typeof arg === \"number\") {\n\t\t\tinitial_size = arg;\n\t\t} else if (arg instanceof Uint8Array) {\n\t\t\tthis.buffer = arg;\n\t\t\tthis.position = 0; // Overwrite\n\t\t\treturn;\n\t\t} else {\n\t\t\t// typeof arg -> String\n\t\t\tthrow `${typeof arg} is invalid parameter type for ByteBuffer constructor`;\n\t\t}\n\t\t// arg is null or number\n\t\tthis.buffer = new Uint8Array(initial_size);\n\t\tthis.position = 0;\n\t}\n\tsize() {\n\t\treturn this.buffer.length;\n\t}\n\treallocate() {\n\t\tconst new_array = new Uint8Array(this.buffer.length * 2);\n\t\tnew_array.set(this.buffer);\n\t\tthis.buffer = new_array;\n\t}\n\tshrink() {\n\t\tthis.buffer = this.buffer.subarray(0, this.position);\n\t\treturn this.buffer;\n\t}\n\tput(b: number) {\n\t\tif (this.buffer.length < this.position + 1) {\n\t\t\tthis.reallocate();\n\t\t}\n\t\tthis.buffer[this.position++] = b;\n\t}\n\tget(index?: number) {\n\t\tif (index == null) {\n\t\t\tindex = this.position;\n\t\t\tthis.position += 1;\n\t\t}\n\t\tif (this.buffer.length < index + 1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.buffer[index];\n\t}\n\t// Write short to buffer by little endian\n\tputShort(num: string | number) {\n\t\tnum = Number(num);\n\t\tif (0xffff < num) {\n\t\t\tthrow `${num} is over short value`;\n\t\t}\n\t\tconst lower = 0x00ff & num;\n\t\tconst upper = (0xff00 & num) >> 8;\n\t\tthis.put(lower);\n\t\tthis.put(upper);\n\t}\n\t// Read short from buffer by little endian\n\tgetShort(index?: number) {\n\t\tif (index == null) {\n\t\t\tindex = this.position;\n\t\t\tthis.position += 2;\n\t\t}\n\t\tif (this.buffer.length < index + 2) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst lower = this.buffer[index];\n\t\tconst upper = this.buffer[index + 1];\n\t\tlet value = (upper << 8) + lower;\n\t\tif (value & 0x8000) {\n\t\t\tvalue = -((value - 1) ^ 0xffff);\n\t\t}\n\t\treturn value;\n\t}\n\t// Write integer to buffer by little endian\n\tputInt(num: string | number) {\n\t\tnum = Number(num);\n\t\tif (0xffffffff < num) {\n\t\t\tthrow `${num} is over integer value`;\n\t\t}\n\t\tconst b0 = 0x000000ff & num;\n\t\tconst b1 = (0x0000ff00 & num) >> 8;\n\t\tconst b2 = (0x00ff0000 & num) >> 16;\n\t\tconst b3 = (0xff000000 & num) >> 24;\n\t\tthis.put(b0);\n\t\tthis.put(b1);\n\t\tthis.put(b2);\n\t\tthis.put(b3);\n\t}\n\t// Read integer from buffer by little endian\n\tgetInt(index?: number) {\n\t\tif (index == null) {\n\t\t\tindex = this.position;\n\t\t\tthis.position += 4;\n\t\t}\n\t\tif (this.buffer.length < index + 4) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst b0 = this.buffer[index];\n\t\tconst b1 = this.buffer[index + 1];\n\t\tconst b2 = this.buffer[index + 2];\n\t\tconst b3 = this.buffer[index + 3];\n\n\t\treturn (b3 << 24) + (b2 << 16) + (b1 << 8) + b0;\n\t}\n\treadInt() {\n\t\tconst pos = this.position;\n\t\tthis.position += 4;\n\t\treturn this.getInt(pos);\n\t}\n\tputString(str: string) {\n\t\tconst bytes = stringToUtf8Bytes(str);\n\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\tthis.put(bytes[i]);\n\t\t}\n\t\t// put null character as terminal character\n\t\tthis.put(0);\n\t}\n\tgetString(index = this.position) {\n\t\tconst buf: number[] = [];\n\t\tlet ch: number;\n\t\twhile (true) {\n\t\t\tif (this.buffer.length < index + 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = this.get(index++);\n\t\t\tif (ch === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf.push(ch);\n\t\t}\n\t\tthis.position = index;\n\t\treturn utf8BytesToString(buf);\n\t}\n}\n\nexport default ByteBuffer;\n","import ByteBuffer from \"../util/ByteBuffer\";\nimport CharacterDefinition from \"./CharacterDefinition\";\nimport type InvokeDefinitionMap from \"./InvokeDefinitionMap\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\n\n/**\n * UnknownDictionary\n * @constructor\n */\n// Inherit from TokenInfoDictionary as a super class\nclass UnknownDictionary extends TokenInfoDictionary {\n\tcharacter_definition?: CharacterDefinition;\n\tconstructor() {\n\t\tsuper();\n\t\tthis.dictionary = new ByteBuffer(10 * 1024 * 1024);\n\t\tthis.target_map = {}; // class_id (of CharacterClass) -> token_info_id (of unknown class)\n\t\tthis.pos_buffer = new ByteBuffer(10 * 1024 * 1024);\n\t}\n\tcharacterDefinition(character_definition: CharacterDefinition) {\n\t\tthis.character_definition = character_definition;\n\t\treturn this;\n\t}\n\tlookup(ch: string) {\n\t\tif (!this.character_definition) {\n\t\t\tthrow new Error(\"Character definition is not initialized\");\n\t\t}\n\t\treturn this.character_definition.lookup(ch);\n\t}\n\tlookupCompatibleCategory(ch: string) {\n\t\tif (!this.character_definition) {\n\t\t\tthrow new Error(\"Character definition is not initialized\");\n\t\t}\n\t\treturn this.character_definition.lookupCompatibleCategory(ch);\n\t}\n\tloadUnknownDictionaries(\n\t\tunk_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_pos_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_map_buffer: Uint8Array<ArrayBufferLike>,\n\t\tcat_map_buffer: Uint8Array,\n\t\tcompat_cat_map_buffer: Uint32Array,\n\t\tinvoke_def_buffer: Uint8Array,\n\t) {\n\t\tthis.loadDictionary(unk_buffer);\n\t\tthis.loadPosVector(unk_pos_buffer);\n\t\tthis.loadTargetMap(unk_map_buffer);\n\t\tthis.character_definition = CharacterDefinition.load(\n\t\t\tcat_map_buffer,\n\t\t\tcompat_cat_map_buffer,\n\t\t\tinvoke_def_buffer,\n\t\t);\n\t}\n}\n\nexport default UnknownDictionary;\n","import SurrogateAwareString from \"../util/SurrogateAwareString\";\nimport CharacterClass from \"./CharacterClass\";\nimport InvokeDefinitionMap from \"./InvokeDefinitionMap\";\n\nconst DEFAULT_CATEGORY = \"DEFAULT\";\n\n/**\n * CharacterDefinition represents char.def file and\n * defines behavior of unknown word processing\n * @constructor\n */\nclass CharacterDefinition {\n\tcharacter_category_map: Uint8Array;\n\tcompatible_category_map: Uint32Array;\n\tinvoke_definition_map?: InvokeDefinitionMap;\n\n\tconstructor() {\n\t\tthis.character_category_map = new Uint8Array(65536); // for all UCS2 code points\n\t\tthis.compatible_category_map = new Uint32Array(65536); // for all UCS2 code points\n\t}\n\t/**\n\t * Load CharacterDefinition\n\t * @param {Uint8Array} cat_map_buffer\n\t * @param {Uint32Array} compat_cat_map_buffer\n\t * @param {InvokeDefinitionMap} invoke_def_buffer\n\t * @returns {CharacterDefinition}\n\t */\n\tstatic load(\n\t\tcat_map_buffer: Uint8Array,\n\t\tcompat_cat_map_buffer: Uint32Array,\n\t\tinvoke_def_buffer: Uint8Array,\n\t): CharacterDefinition {\n\t\tconst char_def = new CharacterDefinition();\n\t\tchar_def.character_category_map = cat_map_buffer;\n\t\tchar_def.compatible_category_map = compat_cat_map_buffer;\n\t\tchar_def.invoke_definition_map =\n\t\t\tInvokeDefinitionMap.load(invoke_def_buffer);\n\t\treturn char_def;\n\t}\n\tstatic parseCharCategory(class_id: number, parsed_category_def: string[]) {\n\t\tconst category = parsed_category_def[1];\n\t\tconst invoke = Number.parseInt(parsed_category_def[2]);\n\t\tconst grouping = Number.parseInt(parsed_category_def[3]);\n\t\tconst max_length = Number.parseInt(parsed_category_def[4]);\n\t\tif (!Number.isFinite(invoke) || (invoke !== 0 && invoke !== 1)) {\n\t\t\tconsole.log(`char.def parse error. INVOKE is 0 or 1 in:${invoke}`);\n\t\t\treturn null;\n\t\t}\n\t\tif (!Number.isFinite(grouping) || (grouping !== 0 && grouping !== 1)) {\n\t\t\tconsole.log(`char.def parse error. GROUP is 0 or 1 in:${grouping}`);\n\t\t\treturn null;\n\t\t}\n\t\tif (!Number.isFinite(max_length) || max_length < 0) {\n\t\t\tconsole.log(`char.def parse error. LENGTH is 1 to n:${max_length}`);\n\t\t\treturn null;\n\t\t}\n\t\tconst is_invoke = invoke === 1;\n\t\tconst is_grouping = grouping === 1;\n\n\t\treturn new CharacterClass(\n\t\t\tclass_id,\n\t\t\tcategory,\n\t\t\tis_invoke,\n\t\t\tis_grouping,\n\t\t\tmax_length,\n\t\t);\n\t}\n\tstatic parseCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n\t\tconst start = Number.parseInt(parsed_category_mapping[1]);\n\t\tconst default_category = parsed_category_mapping[2];\n\t\tconst compatible_category =\n\t\t\t3 < parsed_category_mapping.length\n\t\t\t\t? parsed_category_mapping.slice(3)\n\t\t\t\t: [];\n\t\tif (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n\t\t\tconsole.log(`char.def parse error. CODE is invalid:${start}`);\n\t\t}\n\t\treturn {\n\t\t\tstart: start,\n\t\t\tdefault: default_category,\n\t\t\tcompatible: compatible_category,\n\t\t};\n\t}\n\tstatic parseRangeCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n\t\tconst start = Number.parseInt(parsed_category_mapping[1]);\n\t\tconst end = Number.parseInt(parsed_category_mapping[2]);\n\t\tconst default_category = parsed_category_mapping[3];\n\t\tconst compatible_category =\n\t\t\t4 < parsed_category_mapping.length\n\t\t\t\t? parsed_category_mapping.slice(4)\n\t\t\t\t: [];\n\t\tif (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n\t\t\tconsole.log(`char.def parse error. CODE is invalid:${start}`);\n\t\t}\n\t\tif (!Number.isFinite(end) || end < 0 || end > 0xffff) {\n\t\t\tconsole.log(`char.def parse error. CODE is invalid:${end}`);\n\t\t}\n\t\treturn {\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tdefault: default_category,\n\t\t\tcompatible: compatible_category,\n\t\t};\n\t}\n\t/**\n\t * Initializing method\n\t * @param {Array} category_mapping Array of category mapping\n\t */\n\tinitCategoryMappings(\n\t\tcategory_mapping: {\n\t\t\tstart: number;\n\t\t\tend?: number;\n\t\t\tdefault: string;\n\t\t\tcompatible: string[];\n\t\t}[],\n\t) {\n\t\tif (!this.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\t// Initialize map by DEFAULT class\n\t\tlet code_point: number;\n\t\tif (category_mapping != null) {\n\t\t\tfor (let i = 0; i < category_mapping.length; i++) {\n\t\t\t\tconst mapping = category_mapping[i];\n\t\t\t\tconst end = mapping.end || mapping.start;\n\t\t\t\tfor (code_point = mapping.start; code_point <= end; code_point++) {\n\t\t\t\t\t// Default Category class ID\n\t\t\t\t\tthis.character_category_map[code_point] =\n\t\t\t\t\t\tthis.invoke_definition_map.lookup(mapping.default);\n\n\t\t\t\t\tfor (let j = 0; j < mapping.compatible.length; j++) {\n\t\t\t\t\t\tlet bitset = this.compatible_category_map[code_point];\n\t\t\t\t\t\tconst compatible_category = mapping.compatible[j];\n\t\t\t\t\t\tif (compatible_category == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst class_id =\n\t\t\t\t\t\t\tthis.invoke_definition_map.lookup(compatible_category); // Default Category\n\t\t\t\t\t\tif (class_id == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst class_id_bit = 1 << class_id;\n\t\t\t\t\t\tbitset = bitset | class_id_bit; // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n\t\t\t\t\t\tthis.compatible_category_map[code_point] = bitset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n\t\tif (default_id == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (\n\t\t\tcode_point = 0;\n\t\t\tcode_point < this.character_category_map.length;\n\t\t\tcode_point++\n\t\t) {\n\t\t\t// 他に何のクラスも定義されていなかったときだけ DEFAULT\n\t\t\tif (this.character_category_map[code_point] === 0) {\n\t\t\t\t// DEFAULT class ID に対応するビットだけ1を立てる\n\t\t\t\tthis.character_category_map[code_point] = 1 << default_id;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Lookup compatible categories for a character (not included 1st category)\n\t * @param {string} ch UCS2 character (just 1st character is effective)\n\t * @returns {Array.<CharacterClass>} character classes\n\t */\n\tlookupCompatibleCategory(ch: string): CharacterClass[] {\n\t\tif (!this.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\tconst classes: CharacterClass[] = [];\n\n\t\t/*\n         if (SurrogateAwareString.isSurrogatePair(ch)) {\n         // Surrogate pair character codes can not be defined by char.def\n         return classes;\n         }*/\n\t\tconst code = ch.charCodeAt(0);\n\t\tlet integer: number | undefined = undefined;\n\t\tif (code < this.compatible_category_map.length) {\n\t\t\tinteger = this.compatible_category_map[code]; // Bitset\n\t\t}\n\n\t\tif (integer == null || integer === 0) {\n\t\t\treturn classes;\n\t\t}\n\n\t\tfor (let bit = 0; bit < 32; bit++) {\n\t\t\t// Treat \"bit\" as a class ID\n\t\t\tif ((integer << (31 - bit)) >>> 31 === 1) {\n\t\t\t\tconst character_class =\n\t\t\t\t\tthis.invoke_definition_map.getCharacterClass(bit);\n\t\t\t\tif (character_class == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclasses.push(character_class);\n\t\t\t}\n\t\t}\n\t\treturn classes;\n\t}\n\t/**\n\t * Lookup category for a character\n\t * @param {string} ch UCS2 character (just 1st character is effective)\n\t * @returns {CharacterClass} character class\n\t */\n\tlookup(ch: string): CharacterClass {\n\t\tif (!this.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\tlet class_id: number | undefined;\n\n\t\tconst code = ch.charCodeAt(0);\n\t\tif (SurrogateAwareString.isSurrogatePair(ch)) {\n\t\t\t// Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n\t\t\tclass_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n\t\t} else if (code < this.character_category_map.length) {\n\t\t\tclass_id = this.character_category_map[code]; // Read as integer value\n\t\t}\n\n\t\tif (class_id == null) {\n\t\t\tclass_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n\t\t}\n\n\t\treturn this.invoke_definition_map.getCharacterClass(class_id);\n\t}\n}\n\nexport default CharacterDefinition;\n","/**\n * CharacterClass\n * @param {number} class_id\n * @param {string} class_name\n * @param {boolean} is_always_invoke\n * @param {boolean} is_grouping\n * @param {number} max_length\n * @constructor\n */\nclass CharacterClass {\n\tclass_id: number;\n\tclass_name: string;\n\tis_always_invoke: boolean;\n\tis_grouping: boolean;\n\tmax_length: number;\n\tconstructor(\n\t\tclass_id: number,\n\t\tclass_name: string,\n\t\tis_always_invoke: boolean,\n\t\tis_grouping: boolean,\n\t\tmax_length: number,\n\t) {\n\t\tthis.class_id = class_id;\n\t\tthis.class_name = class_name;\n\t\tthis.is_always_invoke = is_always_invoke;\n\t\tthis.is_grouping = is_grouping;\n\t\tthis.max_length = max_length;\n\t}\n}\n\nexport default CharacterClass;\n","import ByteBuffer from \"../util/ByteBuffer\";\nimport CharacterClass from \"./CharacterClass\";\n\n/**\n * InvokeDefinitionMap represents invoke definition a part of char.def\n * @constructor\n */\nclass InvokeDefinitionMap {\n\tmap: CharacterClass[];\n\tlookup_table: { [x: string]: number };\n\n\tconstructor() {\n\t\tthis.map = [];\n\t\tthis.lookup_table = {}; // Just for building dictionary\n\t}\n\t/**\n\t * Load InvokeDefinitionMap from buffer\n\t * @param {Uint8Array} invoke_def_buffer\n\t * @returns {InvokeDefinitionMap}\n\t */\n\tstatic load(invoke_def_buffer: Uint8Array): InvokeDefinitionMap {\n\t\tconst invoke_def = new InvokeDefinitionMap();\n\t\tconst character_category_definition: CharacterClass[] = [];\n\n\t\tconst buffer = new ByteBuffer(invoke_def_buffer);\n\t\twhile (buffer.position + 1 < buffer.size()) {\n\t\t\tconst class_id = character_category_definition.length;\n\t\t\tconst is_always_invoke = buffer.get() === 1;\n\t\t\tconst is_grouping = buffer.get() === 1;\n\t\t\tconst max_length = buffer.getInt();\n\t\t\tconst class_name = buffer.getString();\n\t\t\tcharacter_category_definition.push(\n\t\t\t\tnew CharacterClass(\n\t\t\t\t\tclass_id,\n\t\t\t\t\tclass_name,\n\t\t\t\t\tis_always_invoke,\n\t\t\t\t\tis_grouping,\n\t\t\t\t\tmax_length,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tinvoke_def.init(character_category_definition);\n\n\t\treturn invoke_def;\n\t}\n\t/**\n\t * Initializing method\n\t * @param {Array.<CharacterClass>} character_category_definition Array of CharacterClass\n\t */\n\tinit(character_category_definition: CharacterClass[]) {\n\t\tif (character_category_definition == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < character_category_definition.length; i++) {\n\t\t\tconst character_class = character_category_definition[i];\n\t\t\tthis.map[i] = character_class;\n\t\t\tthis.lookup_table[character_class.class_name] = i;\n\t\t}\n\t}\n\t/**\n\t * Get class information by class ID\n\t * @param {number} class_id\n\t * @returns {CharacterClass}\n\t */\n\tgetCharacterClass(class_id: number): CharacterClass {\n\t\treturn this.map[class_id];\n\t}\n\t/**\n\t * For building character definition dictionary\n\t * @param {string} class_name character\n\t * @returns {number} class_id\n\t */\n\tlookup(class_name: string): number {\n\t\tconst class_id = this.lookup_table[class_name];\n\t\tif (class_id == null) {\n\t\t\tthrow new Error(\"null\");\n\t\t}\n\t\treturn class_id;\n\t}\n\t/**\n\t * Transform from map to binary buffer\n\t * @returns {Uint8Array}\n\t */\n\ttoBuffer(): Uint8Array {\n\t\tconst buffer = new ByteBuffer();\n\t\tfor (let i = 0; i < this.map.length; i++) {\n\t\t\tconst char_class = this.map[i];\n\t\t\tbuffer.put(Number(char_class.is_always_invoke));\n\t\t\tbuffer.put(Number(char_class.is_grouping));\n\t\t\tbuffer.putInt(char_class.max_length);\n\t\t\tbuffer.putString(char_class.class_name);\n\t\t}\n\t\tbuffer.shrink();\n\t\treturn buffer.buffer;\n\t}\n}\n\nexport default InvokeDefinitionMap;\n","import type CharacterClass from \"../CharacterClass\";\nimport CharacterDefinition from \"../CharacterDefinition\";\nimport InvokeDefinitionMap from \"../InvokeDefinitionMap\";\n\nconst CATEGORY_DEF_PATTERN = /^(\\w+)\\s+(\\d)\\s+(\\d)\\s+(\\d)/;\nconst CATEGORY_MAPPING_PATTERN =\n\t/^(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\nconst RANGE_CATEGORY_MAPPING_PATTERN =\n\t/^(0x[0-9A-F]{4})\\.\\.(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\n\n/**\n * CharacterDefinitionBuilder\n * @constructor\n */\nclass CharacterDefinitionBuilder {\n\tchar_def: CharacterDefinition;\n\tcharacter_category_definition: CharacterClass[];\n\tcategory_mapping: {\n\t\tstart: number;\n\t\tend?: number;\n\t\tdefault: string;\n\t\tcompatible: string[];\n\t}[];\n\tconstructor() {\n\t\tthis.char_def = new CharacterDefinition();\n\t\tthis.char_def.invoke_definition_map = new InvokeDefinitionMap();\n\t\tthis.character_category_definition = [];\n\t\tthis.category_mapping = [];\n\t}\n\tputLine(line: string) {\n\t\tconst parsed_category_def = CATEGORY_DEF_PATTERN.exec(line);\n\t\tif (parsed_category_def != null) {\n\t\t\tconst class_id = this.character_category_definition.length;\n\t\t\tconst char_class = CharacterDefinition.parseCharCategory(\n\t\t\t\tclass_id,\n\t\t\t\tparsed_category_def,\n\t\t\t);\n\t\t\tif (char_class == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.character_category_definition.push(char_class);\n\t\t\treturn;\n\t\t}\n\t\tconst parsed_category_mapping = CATEGORY_MAPPING_PATTERN.exec(line);\n\t\tif (parsed_category_mapping != null) {\n\t\t\tconst mapping = CharacterDefinition.parseCategoryMapping(\n\t\t\t\tparsed_category_mapping,\n\t\t\t);\n\t\t\tthis.category_mapping.push(mapping);\n\t\t}\n\t\tconst parsed_range_category_mapping =\n\t\t\tRANGE_CATEGORY_MAPPING_PATTERN.exec(line);\n\t\tif (parsed_range_category_mapping != null) {\n\t\t\tconst range_mapping = CharacterDefinition.parseRangeCategoryMapping(\n\t\t\t\tparsed_range_category_mapping,\n\t\t\t);\n\t\t\tthis.category_mapping.push(range_mapping);\n\t\t}\n\t}\n\tbuild() {\n\t\t// TODO If DEFAULT category does not exist, throw error\n\t\tif (!this.char_def.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\tthis.char_def.invoke_definition_map.init(\n\t\t\tthis.character_category_definition,\n\t\t);\n\t\tthis.char_def.initCategoryMappings(this.category_mapping);\n\t\treturn this.char_def;\n\t}\n}\n\nexport default CharacterDefinitionBuilder;\n","import ConnectionCosts from \"../ConnectionCosts\";\n\n/**\n * Builder class for constructing ConnectionCosts object\n * @constructor\n */\nclass ConnectionCostsBuilder {\n\tlines: number;\n\tconnection_cost?: ConnectionCosts;\n\tconstructor() {\n\t\tthis.lines = 0;\n\t}\n\tputLine(line: string) {\n\t\tif (this.lines === 0) {\n\t\t\tconst dimensions = line.split(\" \");\n\t\t\tconst forward_dimension = Number.parseInt(dimensions[0]);\n\t\t\tconst backward_dimension = Number.parseInt(dimensions[1]);\n\n\t\t\tif (forward_dimension < 0 || backward_dimension < 0) {\n\t\t\t\tthrow \"Parse error of matrix.def\";\n\t\t\t}\n\n\t\t\tthis.connection_cost = new ConnectionCosts(\n\t\t\t\tforward_dimension,\n\t\t\t\tbackward_dimension,\n\t\t\t);\n\t\t\tthis.lines++;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst costs = line.split(\" \");\n\n\t\tif (costs.length !== 3) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst forward_id = Number.parseInt(costs[0]);\n\t\tconst backward_id = Number.parseInt(costs[1]);\n\t\tconst cost = Number.parseInt(costs[2]);\n\n\t\tif (\n\t\t\tforward_id < 0 ||\n\t\t\tbackward_id < 0 ||\n\t\t\t!Number.isFinite(forward_id) ||\n\t\t\t!Number.isFinite(backward_id) ||\n\t\t\tthis.connection_cost?.forward_dimension! <= forward_id ||\n\t\t\tthis.connection_cost?.backward_dimension! <= backward_id\n\t\t) {\n\t\t\tthrow \"Parse error of matrix.def\";\n\t\t}\n\n\t\tthis.connection_cost?.put(forward_id, backward_id, cost);\n\t\tthis.lines++;\n\t\treturn this;\n\t}\n\tbuild(): ConnectionCosts {\n\t\tif (!this.connection_cost) {\n\t\t\tthrow new Error(\"ConnectionCosts is not initialized\");\n\t\t}\n\t\treturn this.connection_cost;\n\t}\n}\n\nexport default ConnectionCostsBuilder;\n","import DynamicDictionaries from \"../dict/DynamicDictionaries\";\nimport BunDecompressionStream from \"../util/BunCompressionStreams\";\nimport type manifest from \"../util/manifest\";\nimport type { DetailedDicPath, DetailedFile } from \"../util/manifest\";\n\ndeclare global {\n\tvar Deno: any;\n\tvar Bun: any;\n\tvar process: any;\n}\n// Export the CompressionFormat enum and DecompressionStream class if needed for module usage.\nexport type CompressionFormat = \"deflate\" | \"deflate-raw\" | \"gzip\";\n// Pollyfill of DecompressionStream for Bun\nglobalThis.DecompressionStream ??= BunDecompressionStream;\n\n/**\n * DictionaryLoader base constructor\n * @param {string} dic_path Dictionary path\n * @constructor\n */\nclass DictionaryLoader {\n\tdic_path: DetailedDicPath;\n\tconstructor(dic_path: manifest[\"dicPath\"]) {\n\t\tlet dicPath: DetailedDicPath;\n\t\tdic_path ??= \"/dict\";\n\t\tif (typeof dic_path !== \"string\") {\n\t\t\tdicPath = {\n\t\t\t\ttid: {\n\t\t\t\t\tdict: \"tid.dat.gz\",\n\t\t\t\t\tmap: \"tid_map.dat.gz\",\n\t\t\t\t\tpos: \"tid_pos.dat.gz\",\n\t\t\t\t},\n\t\t\t\tunk: {\n\t\t\t\t\tdict: \"unk.dat.gz\",\n\t\t\t\t\tmap: \"unk_map.dat.gz\",\n\t\t\t\t\tpos: \"unk_pos.dat.gz\",\n\t\t\t\t},\n\t\t\t\tcc: \"cc.dat.gz\",\n\t\t\t\tchr: {\n\t\t\t\t\tchar: \"unk_char.dat.gz\",\n\t\t\t\t\tcompat: \"unk_compat.dat.gz\",\n\t\t\t\t\tinvoke: \"unk_invoke.dat.gz\",\n\t\t\t\t},\n\t\t\t\tword: {\n\t\t\t\t\ttype: \"Trie\",\n\t\t\t\t\tbase: \"base.dat.gz\",\n\t\t\t\t\tcheck: \"check.dat.gz\",\n\t\t\t\t},\n\t\t\t\tbase: \"/dict\",\n\t\t\t};\n\t\t\tif (dic_path.word !== undefined) {\n\t\t\t\tdicPath.word = dic_path.word;\n\t\t\t}\n\t\t\tif (dic_path.tid !== undefined) {\n\t\t\t\tdicPath.tid = dic_path.tid;\n\t\t\t}\n\t\t\tif (dic_path.unk !== undefined) {\n\t\t\t\tdicPath.unk = dic_path.unk;\n\t\t\t}\n\n\t\t\tif (dic_path.cc !== undefined) {\n\t\t\t\tdicPath.cc = dic_path.cc;\n\t\t\t}\n\n\t\t\tif (dic_path.chr !== undefined) {\n\t\t\t\tdicPath.chr = dic_path.chr;\n\t\t\t}\n\n\t\t\tif (dic_path.base !== undefined) {\n\t\t\t\tdicPath.base = dic_path.base;\n\t\t\t}\n\t\t} else {\n\t\t\tdicPath = {\n\t\t\t\ttid: {\n\t\t\t\t\tdict: \"tid.dat.gz\",\n\t\t\t\t\tmap: \"tid_map.dat.gz\",\n\t\t\t\t\tpos: \"tid_pos.dat.gz\",\n\t\t\t\t},\n\t\t\t\tunk: {\n\t\t\t\t\tdict: \"unk.dat.gz\",\n\t\t\t\t\tmap: \"unk_map.dat.gz\",\n\t\t\t\t\tpos: \"unk_pos.dat.gz\",\n\t\t\t\t},\n\t\t\t\tcc: \"cc.dat.gz\",\n\t\t\t\tchr: {\n\t\t\t\t\tchar: \"unk_char.dat.gz\",\n\t\t\t\t\tcompat: \"unk_compat.dat.gz\",\n\t\t\t\t\tinvoke: \"unk_invoke.dat.gz\",\n\t\t\t\t},\n\t\t\t\tword: {\n\t\t\t\t\ttype: \"Trie\",\n\t\t\t\t\tbase: \"base.dat.gz\",\n\t\t\t\t\tcheck: \"check.dat.gz\",\n\t\t\t\t},\n\t\t\t\tbase: dic_path,\n\t\t\t};\n\t\t}\n\t\tthis.dic_path = dicPath;\n\t}\n\tasync loadArrayBuffer(\n\t\tbase: string,\n\t\tfile: DetailedFile,\n\t): Promise<ArrayBuffer> {\n\t\tlet compressedData: Uint8Array;\n\t\tif (typeof globalThis.Deno !== \"undefined\") {\n\t\t\t// Okay. I'm on Deno. Let's just read it.\n\t\t\tcompressedData = await Deno.readFile(base + file.path);\n\t\t} else if (typeof globalThis.Bun !== \"undefined\") {\n\t\t\t// Now, I'm on Bun. Let's use `Bun.file`.\n\t\t\tcompressedData = Buffer.from(\n\t\t\t\tawait Bun.file(base + file.path).arrayBuffer(),\n\t\t\t);\n\t\t} else if (typeof globalThis.process !== \"undefined\") {\n\t\t\t// Yep, I guess I'm on Node. read file by using promise!\n\t\t\tconst fs = await import(\"node:fs/promises\");\n\t\t\tcompressedData = await fs.readFile(base + file.path);\n\t\t} else {\n\t\t\t// Looks like I'm in browser. Let's fetch it!\n\t\t\tconst response = await fetch(base + file.path);\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Failed to fetch ${base + file.path}: ${response.statusText}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\t// What the hell... They decompressed it automatically...\n\t\t\treturn await response.arrayBuffer();\n\t\t}\n\n\t\tif (!file.compression) {\n\t\t\tfile.compression = \"gzip\";\n\t\t}\n\t\t// Decompress\n\t\tif (file.compression === \"raw\") {\n\t\t\treturn compressedData.buffer as ArrayBuffer;\n\t\t}\n\n\t\tconst ds = new DecompressionStream(file.compression);\n\t\tconst decompressedStream = new Blob([compressedData])\n\t\t\t.stream()\n\t\t\t.pipeThrough(ds);\n\t\tconst decompressedData = await new Response(\n\t\t\tdecompressedStream,\n\t\t).arrayBuffer();\n\t\treturn decompressedData;\n\t}\n\t/**\n\t * Load dictionary files\n\t */\n\tasync load() {\n\t\tconst dic = new DynamicDictionaries();\n\t\tconst dic_path = this.dic_path;\n\t\tconst loadArrayBuffer = this.loadArrayBuffer;\n\n\t\tawait Promise.all(\n\t\t\t[\n\t\t\t\t// WordDictionary\n\t\t\t\tasync () => {\n\t\t\t\t\tswitch (dic_path.word.type) {\n\t\t\t\t\t\tcase \"FST\": {\n\t\t\t\t\t\t\tconst FSTword_base: DetailedFile =\n\t\t\t\t\t\t\t\ttypeof dic_path.word.base === \"string\"\n\t\t\t\t\t\t\t\t\t? { path: dic_path.word.base }\n\t\t\t\t\t\t\t\t\t: dic_path.word.base;\n\t\t\t\t\t\t\tconst buffer = await loadArrayBuffer(\n\t\t\t\t\t\t\t\t`${dic_path.base}/`,\n\t\t\t\t\t\t\t\tFSTword_base,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tdic.loadFST(new Uint8Array(buffer));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"Trie\": {\n\t\t\t\t\t\t\tconst Trieword_base: DetailedFile =\n\t\t\t\t\t\t\t\ttypeof dic_path.word.base === \"string\"\n\t\t\t\t\t\t\t\t\t? { path: dic_path.word.base }\n\t\t\t\t\t\t\t\t\t: dic_path.word.base;\n\t\t\t\t\t\t\tconst Trieword_check: DetailedFile =\n\t\t\t\t\t\t\t\ttypeof dic_path.word.check === \"string\"\n\t\t\t\t\t\t\t\t\t? { path: dic_path.word.check }\n\t\t\t\t\t\t\t\t\t: dic_path.word.check;\n\t\t\t\t\t\t\tconst buffers = await Promise.all(\n\t\t\t\t\t\t\t\t[Trieword_base, Trieword_check].map(async (file) => {\n\t\t\t\t\t\t\t\t\treturn loadArrayBuffer(`${dic_path.base}/`, file);\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst base_buffer = new Int32Array(buffers[0]);\n\t\t\t\t\t\t\tconst check_buffer = new Int32Array(buffers[1]);\n\n\t\t\t\t\t\t\tdic.loadTrie(base_buffer, check_buffer);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Token info dictionaries\n\t\t\t\tasync () => {\n\t\t\t\t\tconst TID_Dict: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.tid.dict === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.tid.dict }\n\t\t\t\t\t\t\t: dic_path.tid.dict;\n\t\t\t\t\tconst TID_Pos: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.tid.pos === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.tid.pos }\n\t\t\t\t\t\t\t: dic_path.tid.pos;\n\t\t\t\t\tconst TID_Map: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.tid.map === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.tid.map }\n\t\t\t\t\t\t\t: dic_path.tid.map;\n\t\t\t\t\tconst buffers = await Promise.all(\n\t\t\t\t\t\t[TID_Dict, TID_Pos, TID_Map].map((file) => {\n\t\t\t\t\t\t\treturn loadArrayBuffer(`${dic_path.base}/`, file);\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t\tconst token_info_buffer = new Uint8Array(buffers[0]);\n\t\t\t\t\tconst pos_buffer = new Uint8Array(buffers[1]);\n\t\t\t\t\tconst target_map_buffer = new Uint8Array(buffers[2]);\n\n\t\t\t\t\tdic.loadTokenInfoDictionaries(\n\t\t\t\t\t\ttoken_info_buffer,\n\t\t\t\t\t\tpos_buffer,\n\t\t\t\t\t\ttarget_map_buffer,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\t// Connection cost matrix\n\t\t\t\tasync () => {\n\t\t\t\t\tconst UNK_Dict: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.cc === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.cc }\n\t\t\t\t\t\t\t: dic_path.cc;\n\t\t\t\t\tconst buffer = await loadArrayBuffer(`${dic_path.base}/`, UNK_Dict);\n\t\t\t\t\tconst cc_buffer = new Int16Array(buffer);\n\t\t\t\t\tdic.loadConnectionCosts(cc_buffer);\n\t\t\t\t},\n\t\t\t\t// Unknown dictionaries\n\t\t\t\tasync () => {\n\t\t\t\t\tconst UNK_Dict: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.unk.dict === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.unk.dict }\n\t\t\t\t\t\t\t: dic_path.unk.dict;\n\t\t\t\t\tconst UNK_Pos: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.unk.pos === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.unk.pos }\n\t\t\t\t\t\t\t: dic_path.unk.pos;\n\t\t\t\t\tconst UNK_Map: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.unk.map === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.unk.map }\n\t\t\t\t\t\t\t: dic_path.unk.map;\n\t\t\t\t\tconst Char: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.chr.char === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.chr.char }\n\t\t\t\t\t\t\t: dic_path.chr.char;\n\t\t\t\t\tconst Compat: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.chr.compat === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.chr.compat }\n\t\t\t\t\t\t\t: dic_path.chr.compat;\n\t\t\t\t\tconst Invoke: DetailedFile =\n\t\t\t\t\t\ttypeof dic_path.chr.invoke === \"string\"\n\t\t\t\t\t\t\t? { path: dic_path.chr.invoke }\n\t\t\t\t\t\t\t: dic_path.chr.invoke;\n\t\t\t\t\tconst buffers = await Promise.all(\n\t\t\t\t\t\t[UNK_Dict, UNK_Pos, UNK_Map, Char, Compat, Invoke].map(\n\t\t\t\t\t\t\tasync (file) => {\n\t\t\t\t\t\t\t\treturn loadArrayBuffer(`${dic_path.base}/`, file);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tconst unk_buffer = new Uint8Array(buffers[0]);\n\t\t\t\t\tconst unk_pos_buffer = new Uint8Array(buffers[1]);\n\t\t\t\t\tconst unk_map_buffer = new Uint8Array(buffers[2]);\n\t\t\t\t\tconst cat_map_buffer = new Uint8Array(buffers[3]);\n\t\t\t\t\tconst compat_cat_map_buffer = new Uint32Array(buffers[4]);\n\t\t\t\t\tconst invoke_def_buffer = new Uint8Array(buffers[5]);\n\n\t\t\t\t\tdic.loadUnknownDictionaries(\n\t\t\t\t\t\tunk_buffer,\n\t\t\t\t\t\tunk_pos_buffer,\n\t\t\t\t\t\tunk_map_buffer,\n\t\t\t\t\t\tcat_map_buffer,\n\t\t\t\t\t\tcompat_cat_map_buffer,\n\t\t\t\t\t\tinvoke_def_buffer,\n\t\t\t\t\t);\n\t\t\t\t\t// dic.loadUnknownDictionaries(char_buffer, unk_buffer);\n\t\t\t\t},\n\t\t\t].map((func) => func()),\n\t\t);\n\n\t\treturn dic;\n\t}\n}\n\n/**\n * Callback\n * @callback DictionaryLoader~onLoad\n * @param {Object} err Error object\n * @param {DynamicDictionaries} dic Loaded dictionary\n */\n\nexport default DictionaryLoader;\n","/**\r\n * Polyfill for DecompressionStream using Bun's synchronous decompression functions.\r\n */\r\nclass BunDecompressionStream extends TransformStream<Uint8Array, Uint8Array> {\r\n    /**\r\n     * Creates a new DecompressionStream for the given format.\r\n     * @param format The compression format to use for decompression ('deflate', 'deflate-raw', or 'gzip').\r\n     * @throws {TypeError} If the format is unsupported.\r\n     */\r\n    constructor(format: CompressionFormat) {\r\n        if (![\"deflate\", \"deflate-raw\", \"gzip\"].includes(format)) {\r\n            throw new TypeError(`Unsupported compression format: ${format}`);\r\n        }\r\n        let data: Uint8Array;\r\n        super({\r\n            transform(chunk) {\r\n                if (!data) {\r\n                    data = chunk;\r\n                } else {\r\n                    const newData = new Uint8Array(data.length + chunk.length);\r\n                    newData.set(data);\r\n                    newData.set(chunk, data.length);\r\n                    data = newData;\r\n                }\r\n            },\r\n            flush(controller) {\r\n                try {\r\n                    let decompressedBuffer: Uint8Array;\r\n                    if (format === \"gzip\") {\r\n                        decompressedBuffer = Bun.gunzipSync(data);\r\n                    } else if (format === \"deflate\") {\r\n                        decompressedBuffer = Bun.inflateSync(data);\r\n                    } else if (format === \"deflate-raw\") {\r\n                        // Use negative windowBits for raw deflate (no zlib header/footer)\r\n                        decompressedBuffer = Bun.inflateSync(data, { windowBits: -15 }); // -15 is a common value for raw deflate\r\n                    } else {\r\n                        // Should not reach here as format is validated in constructor\r\n                        controller.error(\r\n                            new TypeError(\"Unsupported compression format (internal error)\"),\r\n                        );\r\n                        return;\r\n                    }\r\n                    controller.enqueue(decompressedBuffer);\r\n                } catch (error: any) {\r\n                    // Catching 'any' for broader error capture, refine if Bun's errors are typed.\r\n                    controller.error(\r\n                        new TypeError(`Decompression failed for format '${format}'.`, {\r\n                            cause: error,\r\n                        }),\r\n                    );\r\n                    return;\r\n                }\r\n            },\r\n        });\r\n    }\r\n}\r\n\r\nexport default BunDecompressionStream;","import type { Formatter, Token } from \"./Formatter\";\n\n/**\n * Mappings between IPADIC dictionary features and tokenized results\n * @constructor\n */\nclass IpadicFormatter implements Formatter {\n\tformatEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t) {\n\t\tconst token: Token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: features[0],\n\t\t\tpos: features[1],\n\t\t\tpos_detail_1: features[2],\n\t\t\tpos_detail_2: features[3],\n\t\t\tpos_detail_3: features[4],\n\t\t\tconjugated_type: features[5],\n\t\t\tconjugated_form: features[6],\n\t\t\tbasic_form: features[7],\n\t\t\treading: features[8],\n\t\t\tpronunciation: features[9],\n\t\t};\n\n\t\treturn token;\n\t}\n\tformatUnknownEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t\tsurface_form: string,\n\t) {\n\t\tconst token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: surface_form,\n\t\t\tpos: features[1],\n\t\t\tpos_detail_1: features[2],\n\t\t\tpos_detail_2: features[3],\n\t\t\tpos_detail_3: features[4],\n\t\t\tconjugated_type: features[5],\n\t\t\tconjugated_form: features[6],\n\t\t\tbasic_form: features[7],\n\t\t\t// reading:features[8],\n\t\t\t// pronunciation:features[9],\n\t\t};\n\n\t\treturn token;\n\t}\n}\n\nexport default IpadicFormatter;\n","import type { Formatter, Token } from \"./Formatter\";\n\n/**\n * Mappings between Unidic dictionary features and tokenized results\n * @constructor\n */\nclass UnidicFormatter implements Formatter {\n\tformatEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t) {\n\t\tconst token: Token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: features[1],\n\t\t\tpos: features[2],\n\t\t\tpos_detail_1: features[3],\n\t\t\tpos_detail_2: features[4],\n\t\t\tpos_detail_3: features[5],\n\t\t\tconjugated_type: features[6],\n\t\t\tconjugated_form: features[7],\n\t\t\tbasic_form: features[9],\n\t\t\treading: features[8],\n\t\t};\n\n\t\treturn token;\n\t}\n\tformatUnknownEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t\tsurface_form: string,\n\t) {\n\t\tconst token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: surface_form,\n\t\t\tpos: features[2],\n\t\t\tpos_detail_1: features[3],\n\t\t\tpos_detail_2: features[4],\n\t\t\tpos_detail_3: features[5],\n\t\t\tconjugated_type: features[6],\n\t\t\tconjugated_form: features[7],\n\t\t\tbasic_form: features[10],\n\t\t\t// reading: features[11],\n\t\t};\n\n\t\treturn token;\n\t}\n}\n\nexport default UnidicFormatter;\n"],"names":[],"version":3,"file":"kuromoji.js.map","sourceRoot":"../"}