{"mappings":"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","sources":["src/kuromoji.ts","src/TokenizerBuilder.ts","src/Tokenizer.ts","src/viterbi/ViterbiBuilder.ts","src/util/SurrogateAwareString.ts","src/viterbi/ViterbiLattice.ts","src/viterbi/ViterbiNode.ts","src/viterbi/ViterbiSearcher.ts","src/loader/DictionaryLoader.ts","src/dict/DynamicDictionaries.ts","src/util/DoubleArray.ts","src/dict/ConnectionCosts.ts","src/dict/TokenInfoDictionary.ts","src/util/ByteBuffer.ts","src/dict/UnknownDictionary.ts","src/dict/CharacterDefinition.ts","src/dict/CharacterClass.ts","src/dict/InvokeDefinitionMap.ts","src/util/IpadicFormatter.ts","src/util/UnidicFormater.ts","src/dict/builder/DictionaryBuilder.ts","src/dict/builder/CharacterDefinitionBuilder.ts","src/dict/builder/ConnectionCostsBuilder.ts"],"sourcesContent":["import TokenizerBuilder from \"./TokenizerBuilder\";\nimport DictionaryBuilder from \"./dict/builder/DictionaryBuilder\";\n\n// Public methods\nconst kuromoji = {\n\tbuilder: (option: { dicPath?: string; dicType?: \"UniDic\" | \"IPADic\" }) =>\n\t\tnew TokenizerBuilder(option),\n\tdictionaryBuilder: () => new DictionaryBuilder(),\n};\n\nexport default kuromoji;\n","import Tokenizer from \"./Tokenizer\";\nimport DictionaryLoader from \"./loader/DictionaryLoader\";\nimport IpadicFormatter from \"./util/IpadicFormatter\";\nimport UnidicFormatter from \"./util/UnidicFormater\";\nimport type { Formatter } from \"./util/Formatter\";\n\ntype dicType = \"UniDic\" | \"IPADic\";\n\n/**\n * TokenizerBuilder create Tokenizer instance.\n * @param {Object} option JSON object which have key-value pairs settings\n * @param {string} option.dicPath Dictionary directory path (or URL using in browser)\n * @param {\"UniDic\"|\"IPADic\"} option.dicType Dictionary directory path (or URL using in browser)\n * @constructor\n */\nclass TokenizerBuilder {\n\tdic_path: string;\n\tdic_type: dicType;\n\tdic_formatter: Record<dicType, Formatter> = {\n\t\tUniDic: new UnidicFormatter(),\n\t\tIPADic: new IpadicFormatter(),\n\t};\n\tconstructor(option: { dicPath?: string; dicType?: dicType }) {\n\t\tthis.dic_type = option.dicType ?? \"IPADic\";\n\t\tthis.dic_path = option.dicPath ?? \"dict/\";\n\t}\n\t/**\n\t * Build Tokenizer instance by asynchronous manner\n\t */\n\tasync build(): Promise<Tokenizer> {\n\t\tconst loader = new DictionaryLoader(this.dic_path);\n\t\tawait loader.load();\n\t\treturn new Tokenizer(loader.dic, this.dic_formatter[this.dic_type]);\n\t}\n}\n\nexport default TokenizerBuilder;\n","import type DynamicDictionaries from \"./dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"./dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"./dict/UnknownDictionary\";\nimport type { Token, Formatter } from \"./util/Formatter\";\nimport ViterbiBuilder from \"./viterbi/ViterbiBuilder\";\nimport type ViterbiLattice from \"./viterbi/ViterbiLattice\";\nimport ViterbiSearcher from \"./viterbi/ViterbiSearcher\";\n\nconst PUNCTUATION = /、|。/;\n\n/**\n * Tokenizer\n * @param {DynamicDictionaries} dic Dictionaries used by this tokenizer\n * @constructor\n */\nclass Tokenizer {\n\ttoken_info_dictionary: TokenInfoDictionary;\n\tunknown_dictionary: UnknownDictionary;\n\tviterbi_builder: ViterbiBuilder;\n\tviterbi_searcher: ViterbiSearcher;\n\tformatter: Formatter;\n\tconstructor(dic: DynamicDictionaries, formatter: Formatter) {\n\t\tthis.token_info_dictionary = dic.token_info_dictionary;\n\t\tthis.unknown_dictionary = dic.unknown_dictionary;\n\t\tthis.viterbi_builder = new ViterbiBuilder(dic);\n\t\tthis.viterbi_searcher = new ViterbiSearcher(dic.connection_costs);\n\t\tthis.formatter = formatter;\n\t}\n\t/**\n\t * Split into sentence by punctuation\n\t * @param {string} input Input text\n\t * @returns {Array.<string>} Sentences end with punctuation\n\t */\n\tstatic splitByPunctuation(input: string): Array<string> {\n\t\tconst sentences: string[] = [];\n\t\tlet tail = input;\n\t\twhile (true) {\n\t\t\tif (tail === \"\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst index = tail.search(PUNCTUATION);\n\t\t\tif (index < 0) {\n\t\t\t\tsentences.push(tail);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsentences.push(tail.substring(0, index + 1));\n\t\t\ttail = tail.substring(index + 1);\n\t\t}\n\t\treturn sentences;\n\t}\n\t/**\n\t * Tokenize text\n\t * @param {string} text Input text to analyze\n\t * @returns {Array} Tokens\n\t */\n\ttokenize(text: string): Token[] {\n\t\tconst sentences = Tokenizer.splitByPunctuation(text);\n\t\tconst tokens: Token[] = [];\n\t\tfor (let i = 0; i < sentences.length; i++) {\n\t\t\tconst sentence = sentences[i];\n\t\t\tthis.tokenizeForSentence(sentence, tokens);\n\t\t}\n\t\treturn tokens;\n\t}\n\ttokenizeForSentence(sentence: string, tokens: Token[] = []) {\n\t\tconst lattice = this.getLattice(sentence);\n\t\tconst best_path = this.viterbi_searcher.search(lattice);\n\t\tlet last_pos = 0;\n\t\tif (tokens.length > 0) {\n\t\t\tlast_pos = tokens[tokens.length - 1].word_position;\n\t\t}\n\n\t\tfor (let j = 0; j < best_path.length; j++) {\n\t\t\tconst node = best_path[j];\n\n\t\t\tlet token: Token;\n\t\t\tlet features: string[];\n\t\t\tlet features_line: string | undefined;\n\t\t\tif (node.type === \"KNOWN\") {\n\t\t\t\tfeatures_line = this.token_info_dictionary.getFeatures(\n\t\t\t\t\tnode.name.toString(),\n\t\t\t\t);\n\t\t\t\tif (features_line == null) {\n\t\t\t\t\tfeatures = [];\n\t\t\t\t} else {\n\t\t\t\t\tfeatures = features_line.split(\",\");\n\t\t\t\t}\n\t\t\t\ttoken = this.formatter.formatEntry(\n\t\t\t\t\tnode.name,\n\t\t\t\t\tlast_pos + node.start_pos,\n\t\t\t\t\tnode.type,\n\t\t\t\t\tfeatures,\n\t\t\t\t);\n\t\t\t} else if (node.type === \"UNKNOWN\") {\n\t\t\t\t// Unknown word\n\t\t\t\tfeatures_line = this.unknown_dictionary.getFeatures(\n\t\t\t\t\tnode.name.toString(),\n\t\t\t\t);\n\t\t\t\tif (features_line == null) {\n\t\t\t\t\tfeatures = [];\n\t\t\t\t} else {\n\t\t\t\t\tfeatures = features_line.split(\",\");\n\t\t\t\t}\n\t\t\t\ttoken = this.formatter.formatUnknownEntry(\n\t\t\t\t\tnode.name,\n\t\t\t\t\tlast_pos + node.start_pos,\n\t\t\t\t\tnode.type,\n\t\t\t\t\tfeatures,\n\t\t\t\t\tnode.surface_form,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// TODO User dictionary\n\t\t\t\ttoken = this.formatter.formatEntry(\n\t\t\t\t\tnode.name,\n\t\t\t\t\tlast_pos + node.start_pos,\n\t\t\t\t\tnode.type,\n\t\t\t\t\t[],\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttokens.push(token);\n\t\t}\n\n\t\treturn tokens;\n\t}\n\t/**\n\t * Build word lattice\n\t * @param {string} text Input text to analyze\n\t * @returns {ViterbiLattice} Word lattice\n\t */\n\tgetLattice(text: string): ViterbiLattice {\n\t\treturn this.viterbi_builder.build(text);\n\t}\n}\n\nexport default Tokenizer;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type DynamicDictionaries from \"../dict/DynamicDictionaries\";\nimport type TokenInfoDictionary from \"../dict/TokenInfoDictionary\";\nimport type UnknownDictionary from \"../dict/UnknownDictionary\";\nimport type { DoubleArray } from \"../util/DoubleArray\";\nimport SurrogateAwareString from \"../util/SurrogateAwareString\";\nimport ViterbiLattice from \"./ViterbiLattice\";\nimport ViterbiNode from \"./ViterbiNode\";\n\n/**\n * ViterbiBuilder builds word lattice (ViterbiLattice)\n * @param {DynamicDictionaries} dic dictionary\n * @constructor\n */\nclass ViterbiBuilder {\n\ttrie: DoubleArray;\n\ttoken_info_dictionary: TokenInfoDictionary;\n\tunknown_dictionary: UnknownDictionary;\n\tconstructor(dic: DynamicDictionaries) {\n\t\tthis.trie = dic.trie;\n\t\tthis.token_info_dictionary = dic.token_info_dictionary;\n\t\tthis.unknown_dictionary = dic.unknown_dictionary;\n\t}\n\t/**\n\t * Build word lattice\n\t * @param {string} sentence_str Input text\n\t * @returns {ViterbiLattice} Word lattice\n\t */\n\tbuild(sentence_str: string): ViterbiLattice {\n\t\tconst lattice = new ViterbiLattice();\n\t\tconst sentence = new SurrogateAwareString(sentence_str);\n\n\t\tlet key: string;\n\t\tlet trie_id: string | number;\n\t\tlet left_id: number;\n\t\tlet right_id: number;\n\t\tlet word_cost: number;\n\t\tfor (let pos = 0; pos < sentence.length; pos++) {\n\t\t\tconst tail = sentence.slice(pos);\n\t\t\tconst vocabulary = this.trie.commonPrefixSearch(tail);\n\t\t\tfor (let n = 0; n < vocabulary.length; n++) {\n\t\t\t\t// Words in dictionary do not have surrogate pair (only UCS2 set)\n\t\t\t\ttrie_id = vocabulary[n].v;\n\t\t\t\tkey = vocabulary[n].k as string;\n\n\t\t\t\tconst token_info_ids = this.token_info_dictionary.target_map[trie_id];\n\t\t\t\tfor (let i = 0; i < token_info_ids.length; i++) {\n\t\t\t\t\tconst token_info_id = Number.parseInt(token_info_ids[i].toString());\n\n\t\t\t\t\tleft_id =\n\t\t\t\t\t\tthis.token_info_dictionary.dictionary.getShort(token_info_id);\n\t\t\t\t\tright_id = this.token_info_dictionary.dictionary.getShort(\n\t\t\t\t\t\ttoken_info_id + 2,\n\t\t\t\t\t);\n\t\t\t\t\tword_cost = this.token_info_dictionary.dictionary.getShort(\n\t\t\t\t\t\ttoken_info_id + 4,\n\t\t\t\t\t);\n\n\t\t\t\t\t// node_name, cost, start_index, length, type, left_id, right_id, surface_form\n\t\t\t\t\tlattice.append(\n\t\t\t\t\t\tnew ViterbiNode(\n\t\t\t\t\t\t\ttoken_info_id,\n\t\t\t\t\t\t\tword_cost,\n\t\t\t\t\t\t\tpos + 1,\n\t\t\t\t\t\t\tkey.length,\n\t\t\t\t\t\t\t\"KNOWN\",\n\t\t\t\t\t\t\tleft_id,\n\t\t\t\t\t\t\tright_id,\n\t\t\t\t\t\t\tkey.toString(),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unknown word processing\n\t\t\tconst surrogate_aware_tail = new SurrogateAwareString(tail);\n\t\t\tconst head_char = new SurrogateAwareString(\n\t\t\t\tsurrogate_aware_tail.charAt(0),\n\t\t\t);\n\t\t\tconst head_char_class = this.unknown_dictionary.lookup(\n\t\t\t\thead_char.toString(),\n\t\t\t);\n\t\t\tif (\n\t\t\t\tvocabulary == null ||\n\t\t\t\tvocabulary.length === 0 ||\n\t\t\t\thead_char_class.is_always_invoke\n\t\t\t) {\n\t\t\t\tlet key: SurrogateAwareString;\n\t\t\t\t// Process unknown word\n\t\t\t\tkey = head_char;\n\t\t\t\tif (head_char_class.is_grouping && 1 < surrogate_aware_tail.length) {\n\t\t\t\t\tfor (let k = 1; k < surrogate_aware_tail.length; k++) {\n\t\t\t\t\t\tconst next_char = surrogate_aware_tail.charAt(k);\n\t\t\t\t\t\tconst next_char_class = this.unknown_dictionary.lookup(next_char);\n\t\t\t\t\t\tif (head_char_class.class_name !== next_char_class.class_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkey = new SurrogateAwareString(key.str + next_char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst unk_ids =\n\t\t\t\t\tthis.unknown_dictionary.target_map[head_char_class.class_id];\n\t\t\t\tfor (let j = 0; j < unk_ids.length; j++) {\n\t\t\t\t\tconst unk_id = Number.parseInt(unk_ids[j].toString());\n\n\t\t\t\t\tleft_id = this.unknown_dictionary.dictionary.getShort(unk_id);\n\t\t\t\t\tright_id = this.unknown_dictionary.dictionary.getShort(unk_id + 2);\n\t\t\t\t\tword_cost = this.unknown_dictionary.dictionary.getShort(unk_id + 4);\n\n\t\t\t\t\t// node_name, cost, start_index, length, type, left_id, right_id, surface_form\n\t\t\t\t\tlattice.append(\n\t\t\t\t\t\tnew ViterbiNode(\n\t\t\t\t\t\t\tunk_id,\n\t\t\t\t\t\t\tword_cost,\n\t\t\t\t\t\t\tpos + 1,\n\t\t\t\t\t\t\tkey.length,\n\t\t\t\t\t\t\t\"UNKNOWN\",\n\t\t\t\t\t\t\tleft_id,\n\t\t\t\t\t\t\tright_id,\n\t\t\t\t\t\t\tkey.toString(),\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlattice.appendEos();\n\n\t\treturn lattice;\n\t}\n}\n\nexport default ViterbiBuilder;\n","/**\n * String wrapper for UTF-16 surrogate pair (4 bytes)\n * @param {string} str String to wrap\n * @constructor\n */\nclass SurrogateAwareString {\n\tstr: string;\n\tindex_mapping: number[];\n\tlength: number;\n\tconstructor(str: string) {\n\t\tthis.str = str;\n\t\tthis.index_mapping = [];\n\n\t\tfor (let pos = 0; pos < str.length; pos++) {\n\t\t\tconst ch = str.charAt(pos);\n\t\t\tthis.index_mapping.push(pos);\n\t\t\tif (SurrogateAwareString.isSurrogatePair(ch)) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\t// Surrogate aware length\n\t\tthis.length = this.index_mapping.length;\n\t}\n\tstatic isSurrogatePair(ch: string) {\n\t\tconst utf16_code = ch.charCodeAt(0);\n\t\tif (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n\t\t\t// surrogate pair\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tslice(index: number) {\n\t\tif (this.index_mapping.length <= index) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst surrogate_aware_index = this.index_mapping[index];\n\t\treturn this.str.slice(surrogate_aware_index);\n\t}\n\tcharAt(index: number) {\n\t\tif (this.str.length <= index) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst surrogate_aware_start_index = this.index_mapping[index];\n\t\tconst surrogate_aware_end_index = this.index_mapping[index + 1];\n\n\t\tif (surrogate_aware_end_index == null) {\n\t\t\treturn this.str.slice(surrogate_aware_start_index);\n\t\t}\n\t\treturn this.str.slice(\n\t\t\tsurrogate_aware_start_index,\n\t\t\tsurrogate_aware_end_index,\n\t\t);\n\t}\n\tcharCodeAt(index: number) {\n\t\tif (this.index_mapping.length <= index) {\n\t\t\treturn Number.NaN;\n\t\t}\n\t\tconst surrogate_aware_index = this.index_mapping[index];\n\t\tconst upper = this.str.charCodeAt(surrogate_aware_index);\n\t\tlet lower: number;\n\t\tif (\n\t\t\tupper >= 0xd800 &&\n\t\t\tupper <= 0xdbff &&\n\t\t\tsurrogate_aware_index < this.str.length\n\t\t) {\n\t\t\tlower = this.str.charCodeAt(surrogate_aware_index + 1);\n\t\t\tif (lower >= 0xdc00 && lower <= 0xdfff) {\n\t\t\t\treturn (upper - 0xd800) * 0x400 + lower - 0xdc00 + 0x10000;\n\t\t\t}\n\t\t}\n\t\treturn upper;\n\t}\n\ttoString() {\n\t\treturn this.str;\n\t}\n}\n\nexport default SurrogateAwareString;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport ViterbiNode from \"./ViterbiNode\";\n\n/**\n * ViterbiLattice is a lattice in Viterbi algorithm\n * @constructor\n */\nclass ViterbiLattice {\n\tnodes_end_at: ViterbiNode[][];\n\teos_pos: number;\n\n\tconstructor() {\n\t\tthis.nodes_end_at = [];\n\t\tthis.nodes_end_at[0] = [new ViterbiNode(-1, 0, 0, 0, \"BOS\", 0, 0, \"\")];\n\t\tthis.eos_pos = 1;\n\t}\n\t/**\n\t * Append node to ViterbiLattice\n\t * @param {ViterbiNode} node\n\t */\n\tappend(node: ViterbiNode) {\n\t\tconst last_pos = node.start_pos + node.length - 1;\n\t\tif (this.eos_pos < last_pos) {\n\t\t\tthis.eos_pos = last_pos;\n\t\t}\n\n\t\tlet prev_nodes = this.nodes_end_at[last_pos];\n\t\tif (prev_nodes == null) {\n\t\t\tprev_nodes = [];\n\t\t}\n\t\tprev_nodes.push(node);\n\n\t\tthis.nodes_end_at[last_pos] = prev_nodes;\n\t}\n\t/**\n\t * Set ends with EOS (End of Statement)\n\t */\n\tappendEos() {\n\t\tconst last_index = this.nodes_end_at.length;\n\t\tthis.eos_pos++;\n\t\tthis.nodes_end_at[last_index] = [\n\t\t\tnew ViterbiNode(-1, 0, this.eos_pos, 0, \"EOS\", 0, 0, \"\"),\n\t\t];\n\t}\n}\n\nexport default ViterbiLattice;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * ViterbiNode is a node of ViterbiLattice\n * @param {number} node_name Word ID\n * @param {number} node_cost Word cost to generate\n * @param {number} start_pos Start position from 1\n * @param {number} length Word length\n * @param {string} type Node type (KNOWN, UNKNOWN, BOS, EOS, ...)\n * @param {number} left_id Left context ID\n * @param {number} right_id Right context ID\n * @param {string} surface_form Surface form of this word\n * @constructor\n */\nclass ViterbiNode {\n\tname: number;\n\tcost: number;\n\tstart_pos: number;\n\tlength: number;\n\tleft_id: number;\n\tright_id: number;\n\tprev: ViterbiNode | null;\n\tsurface_form: string;\n\tshortest_cost: number;\n\ttype: string;\n\n\tconstructor(\n\t\tnode_name: number,\n\t\tnode_cost: number,\n\t\tstart_pos: number,\n\t\tlength: number,\n\t\ttype: string,\n\t\tleft_id: number,\n\t\tright_id: number,\n\t\tsurface_form: string,\n\t) {\n\t\tthis.name = node_name;\n\t\tthis.cost = node_cost;\n\t\tthis.start_pos = start_pos;\n\t\tthis.length = length;\n\t\tthis.left_id = left_id;\n\t\tthis.right_id = right_id;\n\t\tthis.prev = null;\n\t\tthis.surface_form = surface_form;\n\t\tif (type === \"BOS\") {\n\t\t\tthis.shortest_cost = 0;\n\t\t} else {\n\t\t\tthis.shortest_cost = Number.MAX_VALUE;\n\t\t}\n\t\tthis.type = type;\n\t}\n}\n\nexport default ViterbiNode;\n","/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type ConnectionCosts from \"../dict/ConnectionCosts\";\nimport type ViterbiLattice from \"./ViterbiLattice\";\nimport type ViterbiNode from \"./ViterbiNode\";\n\n/**\n * ViterbiSearcher is for searching best Viterbi path\n * @param {ConnectionCosts} connection_costs Connection costs matrix\n * @constructor\n */\nclass ViterbiSearcher {\n\tconnection_costs: ConnectionCosts;\n\tconstructor(connection_costs: ConnectionCosts) {\n\t\tthis.connection_costs = connection_costs;\n\t}\n\t/**\n\t * Search best path by forward-backward algorithm\n\t * @param {ViterbiLattice} lattice Viterbi lattice to search\n\t * @returns {Array} Shortest path\n\t */\n\tsearch(lattice: ViterbiLattice): ViterbiNode[] {\n\t\tconst foewarded_lattice = this.forward(lattice);\n\t\treturn this.backward(foewarded_lattice);\n\t}\n\tforward(lattice: ViterbiLattice) {\n\t\tlet i: number;\n\t\tlet j: number;\n\t\tlet k: number;\n\t\tfor (i = 1; i <= lattice.eos_pos; i++) {\n\t\t\tconst nodes = lattice.nodes_end_at[i];\n\t\t\tif (nodes == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j = 0; j < nodes.length; j++) {\n\t\t\t\tconst node = nodes[j];\n\t\t\t\tlet cost = Number.MAX_VALUE;\n\t\t\t\tlet shortest_prev_node: ViterbiNode | null = null;\n\n\t\t\t\tconst prev_nodes = lattice.nodes_end_at[node.start_pos - 1];\n\t\t\t\tif (prev_nodes == null) {\n\t\t\t\t\t// TODO process unknown words (repair word lattice)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < prev_nodes.length; k++) {\n\t\t\t\t\tconst prev_node = prev_nodes[k];\n\n\t\t\t\t\tlet edge_cost: number;\n\t\t\t\t\tif (node.left_id == null || prev_node.right_id == null) {\n\t\t\t\t\t\t// TODO assert\n\t\t\t\t\t\tconsole.log(\"Left or right is null\");\n\t\t\t\t\t\tedge_cost = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedge_cost = this.connection_costs.get(\n\t\t\t\t\t\t\tprev_node.right_id,\n\t\t\t\t\t\t\tnode.left_id,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst _cost = prev_node.shortest_cost + edge_cost + node.cost;\n\t\t\t\t\tif (_cost < cost) {\n\t\t\t\t\t\tshortest_prev_node = prev_node;\n\t\t\t\t\t\tcost = _cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnode.prev = shortest_prev_node;\n\t\t\t\tnode.shortest_cost = cost;\n\t\t\t}\n\t\t}\n\t\treturn lattice;\n\t}\n\tbackward(lattice: ViterbiLattice) {\n\t\tconst shortest_path: ViterbiNode[] = [];\n\t\tconst eos = lattice.nodes_end_at[lattice.nodes_end_at.length - 1][0];\n\n\t\tlet node_back = eos.prev;\n\t\tif (node_back == null) {\n\t\t\treturn [];\n\t\t}\n\t\twhile (node_back.type !== \"BOS\") {\n\t\t\tshortest_path.push(node_back);\n\t\t\tif (node_back.prev == null) {\n\t\t\t\t// TODO Failed to back. Process unknown words?\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tnode_back = node_back.prev;\n\t\t}\n\n\t\treturn shortest_path.reverse();\n\t}\n}\n\nexport default ViterbiSearcher;\n","import DynamicDictionaries from \"../dict/DynamicDictionaries\";\n\n/**\n * Polyfill for DecompressionStream using Bun's synchronous decompression functions.\n */\nclass BunDecompressionStream extends TransformStream<Uint8Array, Uint8Array> {\n\t/**\n\t * Creates a new DecompressionStream for the given format.\n\t * @param format The compression format to use for decompression ('deflate', 'deflate-raw', or 'gzip').\n\t * @throws {TypeError} If the format is unsupported.\n\t */\n\tconstructor(format: CompressionFormat) {\n\t\tif (![\"deflate\", \"deflate-raw\", \"gzip\"].includes(format)) {\n\t\t\tthrow new TypeError(`Unsupported compression format: ${format}`);\n\t\t}\n\t\tlet data: Uint8Array\n\t\tsuper({\n\t\t\ttransform(chunk) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tdata = chunk;\n\t\t\t\t} else {\n\t\t\t\t\tconst newData = new Uint8Array(data.length + chunk.length);\n\t\t\t\t\tnewData.set(data);\n\t\t\t\t\tnewData.set(chunk, data.length);\n\t\t\t\t\tdata = newData;\n\t\t\t\t}\n\t\t\t},\n\t\t\tflush(controller) {\n\t\t\t\ttry {\n\t\t\t\t\tlet decompressedBuffer: Uint8Array;\n\t\t\t\t\tif (format === 'gzip') {\n\t\t\t\t\t\tdecompressedBuffer = Bun.gunzipSync(data);\n\t\t\t\t\t} else if (format === 'deflate') {\n\t\t\t\t\t\tdecompressedBuffer = Bun.inflateSync(data);\n\t\t\t\t\t} else if (format === 'deflate-raw') {\n\t\t\t\t\t\t// Use negative windowBits for raw deflate (no zlib header/footer)\n\t\t\t\t\t\tdecompressedBuffer = Bun.inflateSync(data, { windowBits: -15 }); // -15 is a common value for raw deflate\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Should not reach here as format is validated in constructor\n\t\t\t\t\t\tcontroller.error(new TypeError(\"Unsupported compression format (internal error)\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcontroller.enqueue(decompressedBuffer)\n\t\t\t\t} catch (error: any) { // Catching 'any' for broader error capture, refine if Bun's errors are typed.\n\t\t\t\t\tcontroller.error(new TypeError(`Decompression failed for format '${format}'.`, { cause: error }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Export the CompressionFormat enum and DecompressionStream class if needed for module usage.\nexport type CompressionFormat = \"deflate\" | \"deflate-raw\" | \"gzip\";\n// Pollyfill of DecompressionStream for Bun\nglobalThis.DecompressionStream ??= BunDecompressionStream\n\n/**\n * DictionaryLoader base constructor\n * @param {string} dic_path Dictionary path\n * @constructor\n */\nclass DictionaryLoader {\n\tdic: DynamicDictionaries;\n\tdic_path: string;\n\tconstructor(dic_path: string) {\n\t\tthis.dic = new DynamicDictionaries();\n\t\tthis.dic_path = dic_path;\n\t}\n\tasync loadArrayBuffer(file: string): Promise<ArrayBuffer> {\n\t\tlet compressedData: Uint8Array;\n\t\tif (typeof globalThis.Deno !== \"undefined\") {\n\t\t\t// Okay. I'm on Deno. Let's just read it.\n\t\t\tcompressedData = await Deno.readFile(file);\n\t\t} else if (typeof globalThis.Bun !== \"undefined\") {\n\t\t\t// Now, I'm on Bun. Let's use `Bun.file`.\n\t\t\tcompressedData = Buffer.from(await Bun.file(file).arrayBuffer())\n\t\t} else if (typeof globalThis.process !== \"undefined\") {\n\t\t\t// Yep, I guess I'm on Node. read file by using promise!\n\t\t\tconst fs = await import(\"node:fs/promises\");\n\t\t\tcompressedData = await fs.readFile(file);\n\t\t} else {\n\t\t\t// Looks like I'm in browser. Let's fetch it!\n\t\t\tconst response = await fetch(file);\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow new Error(`Failed to fetch ${file}: ${response.statusText}`);\n\t\t\t}\n\t\t\t// What the hell... They decompressed it automatically...\n\t\t\treturn await response.arrayBuffer();\n\t\t}\n\n\t\t// Decompress gzip\n\t\tconst ds = new DecompressionStream(\"gzip\");\n\t\tconst decompressedStream = new Blob([compressedData])\n\t\t\t.stream()\n\t\t\t.pipeThrough(ds);\n\t\tconst decompressedData = await new Response(\n\t\t\tdecompressedStream,\n\t\t).arrayBuffer();\n\t\treturn decompressedData\n\t}\n\t/**\n\t * Load dictionary files\n\t */\n\tasync load() {\n\t\tconst dic = this.dic;\n\t\tconst dic_path = this.dic_path;\n\t\tconst loadArrayBuffer = this.loadArrayBuffer;\n\n\t\tawait Promise.all(\n\t\t\t[\n\t\t\t\t// Trie\n\t\t\t\tasync () => {\n\t\t\t\t\tconst buffers = await Promise.all(\n\t\t\t\t\t\t[\"base.dat.gz\", \"check.dat.gz\"].map(async (filename) => {\n\t\t\t\t\t\t\treturn loadArrayBuffer(`${dic_path}/${filename}`);\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t\tconst base_buffer = new Int32Array(buffers[0]);\n\t\t\t\t\tconst check_buffer = new Int32Array(buffers[1]);\n\n\t\t\t\t\tdic.loadTrie(base_buffer, check_buffer);\n\t\t\t\t},\n\t\t\t\t// Token info dictionaries\n\t\t\t\tasync () => {\n\t\t\t\t\tconst buffers = await Promise.all(\n\t\t\t\t\t\t[\"tid.dat.gz\", \"tid_pos.dat.gz\", \"tid_map.dat.gz\"].map(\n\t\t\t\t\t\t\tasync (filename) => {\n\t\t\t\t\t\t\t\treturn loadArrayBuffer(`${dic_path}/${filename}`);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\tconst token_info_buffer = new Uint8Array(buffers[0]);\n\t\t\t\t\tconst pos_buffer = new Uint8Array(buffers[1]);\n\t\t\t\t\tconst target_map_buffer = new Uint8Array(buffers[2]);\n\n\t\t\t\t\tdic.loadTokenInfoDictionaries(\n\t\t\t\t\t\ttoken_info_buffer,\n\t\t\t\t\t\tpos_buffer,\n\t\t\t\t\t\ttarget_map_buffer,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\t// Connection cost matrix\n\t\t\t\tasync () => {\n\t\t\t\t\tconst buffer = await loadArrayBuffer(`${dic_path}/cc.dat.gz`);\n\t\t\t\t\tconst cc_buffer = new Int16Array(buffer);\n\t\t\t\t\tdic.loadConnectionCosts(cc_buffer);\n\t\t\t\t},\n\t\t\t\t// Unknown dictionaries\n\t\t\t\tasync () => {\n\t\t\t\t\tconst buffers = await Promise.all(\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\"unk.dat.gz\",\n\t\t\t\t\t\t\t\"unk_pos.dat.gz\",\n\t\t\t\t\t\t\t\"unk_map.dat.gz\",\n\t\t\t\t\t\t\t\"unk_char.dat.gz\",\n\t\t\t\t\t\t\t\"unk_compat.dat.gz\",\n\t\t\t\t\t\t\t\"unk_invoke.dat.gz\",\n\t\t\t\t\t\t].map(async (filename) => {\n\t\t\t\t\t\t\treturn loadArrayBuffer(`${dic_path}/${filename}`);\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t\tconst unk_buffer = new Uint8Array(buffers[0]);\n\t\t\t\t\tconst unk_pos_buffer = new Uint8Array(buffers[1]);\n\t\t\t\t\tconst unk_map_buffer = new Uint8Array(buffers[2]);\n\t\t\t\t\tconst cat_map_buffer = new Uint8Array(buffers[3]);\n\t\t\t\t\tconst compat_cat_map_buffer = new Uint32Array(buffers[4]);\n\t\t\t\t\tconst invoke_def_buffer = new Uint8Array(buffers[5]);\n\n\t\t\t\t\tdic.loadUnknownDictionaries(\n\t\t\t\t\t\tunk_buffer,\n\t\t\t\t\t\tunk_pos_buffer,\n\t\t\t\t\t\tunk_map_buffer,\n\t\t\t\t\t\tcat_map_buffer,\n\t\t\t\t\t\tcompat_cat_map_buffer,\n\t\t\t\t\t\tinvoke_def_buffer,\n\t\t\t\t\t);\n\t\t\t\t\t// dic.loadUnknownDictionaries(char_buffer, unk_buffer);\n\t\t\t\t},\n\t\t\t].map((func) => func()),\n\t\t);\n\n\t\treturn dic;\n\t}\n}\n\n/**\n * Callback\n * @callback DictionaryLoader~onLoad\n * @param {Object} err Error object\n * @param {DynamicDictionaries} dic Loaded dictionary\n */\n\nexport default DictionaryLoader;\n","import { type DoubleArray, builder, load } from \"../util/DoubleArray\";\nimport ConnectionCosts from \"./ConnectionCosts\";\nimport type InvokeDefinitionMap from \"./InvokeDefinitionMap\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\nimport UnknownDictionary from \"./UnknownDictionary\";\n\n/**\n * Dictionaries container for Tokenizer\n * @param {DoubleArray} trie\n * @param {TokenInfoDictionary} token_info_dictionary\n * @param {ConnectionCosts} connection_costs\n * @param {UnknownDictionary} unknown_dictionary\n * @constructor\n */\nclass DynamicDictionaries {\n\ttrie: DoubleArray;\n\ttoken_info_dictionary: TokenInfoDictionary;\n\tconnection_costs: ConnectionCosts;\n\tunknown_dictionary: UnknownDictionary;\n\n\tconstructor(\n\t\ttrie?: DoubleArray,\n\t\ttoken_info_dictionary?: TokenInfoDictionary,\n\t\tconnection_costs?: ConnectionCosts,\n\t\tunknown_dictionary?: UnknownDictionary,\n\t) {\n\t\tif (trie != null) {\n\t\t\tthis.trie = trie;\n\t\t} else {\n\t\t\tthis.trie = builder(0).build([{ k: \"\", v: 1 }]);\n\t\t}\n\t\tif (token_info_dictionary != null) {\n\t\t\tthis.token_info_dictionary = token_info_dictionary;\n\t\t} else {\n\t\t\tthis.token_info_dictionary = new TokenInfoDictionary();\n\t\t}\n\t\tif (connection_costs != null) {\n\t\t\tthis.connection_costs = connection_costs;\n\t\t} else {\n\t\t\t// backward_size * backward_size\n\t\t\tthis.connection_costs = new ConnectionCosts(0, 0);\n\t\t}\n\t\tif (unknown_dictionary != null) {\n\t\t\tthis.unknown_dictionary = unknown_dictionary;\n\t\t} else {\n\t\t\tthis.unknown_dictionary = new UnknownDictionary();\n\t\t}\n\t}\n\t// from base.dat & check.dat\n\tloadTrie(\n\t\tbase_buffer:\n\t\t\t| Int8Array<ArrayBufferLike>\n\t\t\t| Int16Array<ArrayBufferLike>\n\t\t\t| Int32Array<ArrayBufferLike>\n\t\t\t| Uint8Array<ArrayBufferLike>\n\t\t\t| Uint16Array<ArrayBufferLike>\n\t\t\t| Uint32Array<ArrayBufferLike>,\n\t\tcheck_buffer:\n\t\t\t| Int8Array<ArrayBufferLike>\n\t\t\t| Int16Array<ArrayBufferLike>\n\t\t\t| Int32Array<ArrayBufferLike>\n\t\t\t| Uint8Array<ArrayBufferLike>\n\t\t\t| Uint16Array<ArrayBufferLike>\n\t\t\t| Uint32Array<ArrayBufferLike>,\n\t) {\n\t\tthis.trie = load(base_buffer, check_buffer);\n\t\treturn this;\n\t}\n\tloadTokenInfoDictionaries(\n\t\ttoken_info_buffer: Uint8Array<ArrayBufferLike> | undefined,\n\t\tpos_buffer: Uint8Array<ArrayBufferLike> | undefined,\n\t\ttarget_map_buffer: Uint8Array<ArrayBufferLike> | undefined,\n\t) {\n\t\tthis.token_info_dictionary.loadDictionary(token_info_buffer);\n\t\tthis.token_info_dictionary.loadPosVector(pos_buffer);\n\t\tthis.token_info_dictionary.loadTargetMap(target_map_buffer);\n\t\treturn this;\n\t}\n\tloadConnectionCosts(cc_buffer: Int16Array<ArrayBuffer>) {\n\t\tthis.connection_costs.loadConnectionCosts(cc_buffer);\n\t\treturn this;\n\t}\n\tloadUnknownDictionaries(\n\t\tunk_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_pos_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_map_buffer: Uint8Array<ArrayBufferLike>,\n\t\tcat_map_buffer: Uint8Array,\n\t\tcompat_cat_map_buffer: Uint32Array,\n\t\tinvoke_def_buffer: Uint8Array,\n\t) {\n\t\tthis.unknown_dictionary.loadUnknownDictionaries(\n\t\t\tunk_buffer,\n\t\t\tunk_pos_buffer,\n\t\t\tunk_map_buffer,\n\t\t\tcat_map_buffer,\n\t\t\tcompat_cat_map_buffer,\n\t\t\tinvoke_def_buffer,\n\t\t);\n\t\treturn this;\n\t}\n}\n\nexport default DynamicDictionaries;\n","// Copyright (c) 2014 Takuya Asano All Rights Reserved.\n\nconst TERM_CHAR = \"\\u0000\"; // terminal character\nconst TERM_CODE = 0; // terminal character code\nconst ROOT_ID = 0; // index of root node\nconst NOT_FOUND = -1; // traverse() returns if no nodes found\nconst BASE_SIGNED = true;\nconst CHECK_SIGNED = true;\nconst BASE_BYTES = 4;\nconst CHECK_BYTES = 4;\nconst MEMORY_EXPAND_RATIO = 2;\n\ntype Arrays =\n\t| Int8Array\n\t| Int16Array\n\t| Int32Array\n\t| Uint8Array\n\t| Uint16Array\n\t| Uint32Array;\n\ninterface BaseAndCheck {\n\tgetBaseBuffer(): Arrays; // Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array\n\tgetCheckBuffer(): Arrays; // Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array\n\tloadBaseBuffer(base_buffer: Arrays): BaseAndCheck;\n\tloadCheckBuffer(check_buffer: Arrays): BaseAndCheck;\n\tsize(): number;\n\tgetBase(index: number): number;\n\tgetCheck(index: number): number;\n\tsetBase(index: number, base_value: number): void;\n\tsetCheck(index: number, check_value: number): void;\n\tsetFirstUnusedNode(index: number): void;\n\tgetFirstUnusedNode(): number;\n\tshrink(): void;\n\tcalc(): { all: number; unused: number; efficiency: number };\n\tdump(): string;\n}\n\ninterface KeyValue {\n\tk: string | Uint8Array;\n\tv: number;\n}\n\nconst newBC = (initial_size = 1024): BaseAndCheck => {\n\tconst initBase = (_base: Arrays, start: number, end: number) => {\n\t\t// 'end' index does not include\n\t\tfor (let i = start; i < end; i++) {\n\t\t\t_base[i] = -i + 1; // inversed previous empty node index\n\t\t}\n\t\tif (0 < check.array[check.array.length - 1]) {\n\t\t\tlet last_used_id = check.array.length - 2;\n\t\t\twhile (0 < check.array[last_used_id]) {\n\t\t\t\tlast_used_id--;\n\t\t\t}\n\t\t\t_base[start] = -last_used_id;\n\t\t}\n\t};\n\n\tconst initCheck = (_check: Arrays, start: number, end: number) => {\n\t\tfor (let i = start; i < end; i++) {\n\t\t\t_check[i] = -i - 1; // inversed next empty node index\n\t\t}\n\t};\n\n\tconst realloc = (min_size: number) => {\n\t\t// expand arrays size by given ratio\n\t\tconst new_size = min_size * MEMORY_EXPAND_RATIO;\n\t\t// console.log('re-allocate memory to ' + new_size);\n\n\t\tconst base_new_array = newArrayBuffer(base.signed, base.bytes, new_size);\n\t\tinitBase(base_new_array, base.array.length, new_size); // init BASE in new range\n\t\tbase_new_array.set(base.array);\n\t\tbase.array = base_new_array;\n\n\t\tconst check_new_array = newArrayBuffer(check.signed, check.bytes, new_size);\n\t\tinitCheck(check_new_array, check.array.length, new_size); // init CHECK in new range\n\t\tcheck_new_array.set(check.array);\n\t\tcheck.array = check_new_array;\n\t};\n\n\tlet first_unused_node = ROOT_ID + 1;\n\n\tconst base: {\n\t\tsigned: boolean;\n\t\tbytes: number;\n\t\tarray: Arrays;\n\t} = {\n\t\tsigned: BASE_SIGNED,\n\t\tbytes: BASE_BYTES,\n\t\tarray: newArrayBuffer(BASE_SIGNED, BASE_BYTES, initial_size),\n\t};\n\n\tconst check: {\n\t\tsigned: boolean;\n\t\tbytes: number;\n\t\tarray: Arrays;\n\t} = {\n\t\tsigned: CHECK_SIGNED,\n\t\tbytes: CHECK_BYTES,\n\t\tarray: newArrayBuffer(CHECK_SIGNED, CHECK_BYTES, initial_size),\n\t};\n\n\t// init root node\n\tbase.array[ROOT_ID] = 1;\n\tcheck.array[ROOT_ID] = ROOT_ID;\n\n\t// init BASE\n\tinitBase(base.array, ROOT_ID + 1, base.array.length);\n\n\t// init CHECK\n\tinitCheck(check.array, ROOT_ID + 1, check.array.length);\n\n\treturn {\n\t\tgetBaseBuffer: () => base.array,\n\t\tgetCheckBuffer: () => check.array,\n\t\tloadBaseBuffer: function (base_buffer: Arrays) {\n\t\t\tbase.array = base_buffer;\n\t\t\treturn this;\n\t\t},\n\t\tloadCheckBuffer: function (check_buffer: Arrays) {\n\t\t\tcheck.array = check_buffer;\n\t\t\treturn this;\n\t\t},\n\t\tsize: () => Math.max(base.array.length, check.array.length),\n\t\tgetBase: (index: number) => {\n\t\t\tif (base.array.length - 1 < index) {\n\t\t\t\treturn -index + 1;\n\t\t\t\t// realloc(index);\n\t\t\t}\n\t\t\t// if (!Number.isFinite(base.array[index])) {\n\t\t\t//     console.log('getBase:' + index);\n\t\t\t//     throw 'getBase' + index;\n\t\t\t// }\n\t\t\treturn base.array[index];\n\t\t},\n\t\tgetCheck: (index: number) => {\n\t\t\tif (check.array.length - 1 < index) {\n\t\t\t\treturn -index - 1;\n\t\t\t\t// realloc(index);\n\t\t\t}\n\t\t\t// if (!Number.isFinite(check.array[index])) {\n\t\t\t//     console.log('getCheck:' + index);\n\t\t\t//     throw 'getCheck' + index;\n\t\t\t// }\n\t\t\treturn check.array[index];\n\t\t},\n\t\tsetBase: (index: number, base_value: number) => {\n\t\t\tif (base.array.length - 1 < index) {\n\t\t\t\trealloc(index);\n\t\t\t}\n\t\t\tbase.array[index] = base_value;\n\t\t},\n\t\tsetCheck: (index: number, check_value: number) => {\n\t\t\tif (check.array.length - 1 < index) {\n\t\t\t\trealloc(index);\n\t\t\t}\n\t\t\tcheck.array[index] = check_value;\n\t\t},\n\t\tsetFirstUnusedNode: (index: number) => {\n\t\t\t// if (!Number.isFinite(index)) {\n\t\t\t//     throw 'assertion error: setFirstUnusedNode ' + index + ' is not finite number';\n\t\t\t// }\n\t\t\tfirst_unused_node = index;\n\t\t},\n\t\tgetFirstUnusedNode: () => {\n\t\t\t// if (!Number.isFinite(first_unused_node)) {\n\t\t\t//     throw 'assertion error: getFirstUnusedNode ' + first_unused_node + ' is not finite number';\n\t\t\t// }\n\t\t\treturn first_unused_node;\n\t\t},\n\t\tshrink: function () {\n\t\t\tlet last_index = this.size() - 1;\n\t\t\twhile (true) {\n\t\t\t\tif (0 <= check.array[last_index]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlast_index--;\n\t\t\t}\n\t\t\tbase.array = base.array.subarray(0, last_index + 2); // keep last unused node\n\t\t\tcheck.array = check.array.subarray(0, last_index + 2); // keep last unused node\n\t\t},\n\t\tcalc: () => {\n\t\t\tlet unused_count = 0;\n\t\t\tconst size = check.array.length;\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tif (check.array[i] < 0) {\n\t\t\t\t\tunused_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tall: size,\n\t\t\t\tunused: unused_count,\n\t\t\t\tefficiency: (size - unused_count) / size,\n\t\t\t};\n\t\t},\n\t\tdump: function () {\n\t\t\t// for debug\n\t\t\tlet dump_base = \"\";\n\t\t\tlet dump_check = \"\";\n\n\t\t\tlet i: number;\n\t\t\tfor (i = 0; i < base.array.length; i++) {\n\t\t\t\tdump_base = `${dump_base} ${this.getBase(i)}`;\n\t\t\t}\n\t\t\tfor (i = 0; i < check.array.length; i++) {\n\t\t\t\tdump_check = `${dump_check} ${this.getCheck(i)}`;\n\t\t\t}\n\n\t\t\tconsole.log(`base:${dump_base}`);\n\t\t\tconsole.log(`chck:${dump_check}`);\n\n\t\t\treturn `base:${dump_base} chck:${dump_check}`;\n\t\t},\n\t};\n};\n\n/**\n * Factory method of double array\n */\nclass DoubleArrayBuilder {\n\tbc: BaseAndCheck;\n\tkeys: KeyValue[];\n\tconstructor(initial_size: number | undefined) {\n\t\tthis.bc = newBC(initial_size); // BASE and CHECK\n\t\tthis.keys = [];\n\t}\n\t/**\n\t * Append a key to initialize set\n\t * (This method should be called by dictionary ordered key)\n\t *\n\t * @param {String} key\n\t * @param {Number} record Integer value from 0 to max signed integer number - 1\n\t */\n\tappend(key: string, record: number) {\n\t\tthis.keys.push({ k: key, v: record });\n\t\treturn this;\n\t}\n\t/**\n\t * Build double array for given keys\n\t *\n\t * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\n\t * 'k' is a key string, 'v' is a record assigned to that key.\n\t * @return {DoubleArray} Compiled double array\n\t */\n\tbuild(keys: KeyValue[] = this.keys, sorted = false): DoubleArray {\n\t\tif (keys == null) {\n\t\t\treturn new DoubleArray(this.bc);\n\t\t}\n\n\t\t// Convert key string to ArrayBuffer\n\t\tconst buff_keys = keys.map((k: KeyValue) => {\n\t\t\treturn {\n\t\t\t\tk: stringToUtf8Bytes(k.k + TERM_CHAR),\n\t\t\t\tv: k.v,\n\t\t\t};\n\t\t});\n\n\t\t// Sort keys by byte order\n\t\tif (sorted) {\n\t\t\tthis.keys = buff_keys;\n\t\t} else {\n\t\t\tthis.keys = buff_keys.sort((k1: { k: any }, k2: { k: any }) => {\n\t\t\t\tconst b1 = k1.k;\n\t\t\t\tconst b2 = k2.k;\n\t\t\t\tconst min_length = Math.min(b1.length, b2.length);\n\t\t\t\tfor (let pos = 0; pos < min_length; pos++) {\n\t\t\t\t\tif (b1[pos] === b2[pos]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn b1[pos] - b2[pos];\n\t\t\t\t}\n\t\t\t\treturn b1.length - b2.length;\n\t\t\t});\n\t\t}\n\t\tthis._build(ROOT_ID, 0, 0, this.keys.length);\n\t\treturn new DoubleArray(this.bc);\n\t}\n\t/**\n\t * Append nodes to BASE and CHECK array recursively\n\t */\n\t_build(\n\t\tparent_index: number,\n\t\tposition: number,\n\t\tstart: number,\n\t\tlength: number,\n\t) {\n\t\tconst children_info = this.getChildrenInfo(position, start, length);\n\t\tconst _base = this.findAllocatableBase(children_info);\n\n\t\tthis.setBC(parent_index, children_info, _base);\n\n\t\tfor (let i = 0; i < children_info.length; i = i + 3) {\n\t\t\tconst child_code = children_info[i];\n\t\t\tif (child_code === TERM_CODE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst child_start = children_info[i + 1];\n\t\t\tconst child_len = children_info[i + 2];\n\t\t\tconst child_index = _base + child_code;\n\t\t\tthis._build(child_index, position + 1, child_start, child_len);\n\t\t}\n\t}\n\tgetChildrenInfo(position: number, start: number, length: number) {\n\t\tlet current_char = this.keys[start].k[position] as number;\n\t\tlet i = 0;\n\t\tlet children_info = new Int32Array(length * 3);\n\n\t\tchildren_info[i++] = current_char; // char (current)\n\t\tchildren_info[i++] = start; // start index (current)\n\n\t\tlet next_pos = start;\n\t\tlet start_pos = start;\n\t\tfor (; next_pos < start + length; next_pos++) {\n\t\t\tconst next_char = this.keys[next_pos].k[position] as number;\n\t\t\tif (current_char !== next_char) {\n\t\t\t\tchildren_info[i++] = next_pos - start_pos; // length (current)\n\n\t\t\t\tchildren_info[i++] = next_char; // char (next)\n\t\t\t\tchildren_info[i++] = next_pos; // start index (next)\n\t\t\t\tcurrent_char = next_char;\n\t\t\t\tstart_pos = next_pos;\n\t\t\t}\n\t\t}\n\t\tchildren_info[i++] = next_pos - start_pos;\n\t\tchildren_info = children_info.subarray(0, i);\n\n\t\treturn children_info;\n\t}\n\tsetBC(parent_id: number, children_info: Int32Array, _base: number) {\n\t\tconst bc = this.bc;\n\n\t\tbc.setBase(parent_id, _base); // Update BASE of parent node\n\n\t\tlet i: number;\n\t\tfor (i = 0; i < children_info.length; i = i + 3) {\n\t\t\tconst code = children_info[i];\n\t\t\tconst child_id = _base + code;\n\n\t\t\t// Update linked list of unused nodes\n\t\t\t// Assertion\n\t\t\t// if (child_id < 0) {\n\t\t\t//     throw 'assertion error: child_id is negative'\n\t\t\t// }\n\t\t\tconst prev_unused_id = -bc.getBase(child_id);\n\t\t\tconst next_unused_id = -bc.getCheck(child_id);\n\t\t\t// if (prev_unused_id < 0) {\n\t\t\t//     throw 'assertion error: setBC'\n\t\t\t// }\n\t\t\t// if (next_unused_id < 0) {\n\t\t\t//     throw 'assertion error: setBC'\n\t\t\t// }\n\t\t\tif (child_id !== bc.getFirstUnusedNode()) {\n\t\t\t\tbc.setCheck(prev_unused_id, -next_unused_id);\n\t\t\t} else {\n\t\t\t\t// Update first_unused_node\n\t\t\t\tbc.setFirstUnusedNode(next_unused_id);\n\t\t\t}\n\t\t\tbc.setBase(next_unused_id, -prev_unused_id);\n\n\t\t\tconst check = parent_id; // CHECK is parent node index\n\t\t\tbc.setCheck(child_id, check); // Update CHECK of child node\n\n\t\t\t// Update record\n\t\t\tif (code === TERM_CODE) {\n\t\t\t\tconst start_pos = children_info[i + 1];\n\t\t\t\t// var len = children_info[i + 2];\n\t\t\t\t// if (len != 1) {\n\t\t\t\t//     throw 'assertion error: there are multiple terminal nodes. len:' + len;\n\t\t\t\t// }\n\t\t\t\tlet value = this.keys[start_pos].v;\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t}\n\n\t\t\t\tconst base = -value - 1; // BASE is inverted record value\n\t\t\t\tbc.setBase(child_id, base); // Update BASE of child(leaf) node\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Find BASE value that all children are allocatable in double array's region\n\t */\n\tfindAllocatableBase(children_info: Int32Array) {\n\t\tconst bc = this.bc;\n\n\t\t// Assertion: keys are sorted by byte order\n\t\t// var c = -1;\n\t\t// for (var i = 0; i < children_info.length; i = i + 3) {\n\t\t//     if (children_info[i] < c) {\n\t\t//         throw 'assertion error: not sort key'\n\t\t//     }\n\t\t//     c = children_info[i];\n\t\t// }\n\t\t// iterate linked list of unused nodes\n\t\tlet _base: number;\n\t\tlet curr = bc.getFirstUnusedNode(); // current index\n\n\t\t// if (curr < 0) {\n\t\t//     throw 'assertion error: getFirstUnusedNode returns negative value'\n\t\t// }\n\t\twhile (true) {\n\t\t\t_base = curr - children_info[0];\n\n\t\t\tif (_base < 0) {\n\t\t\t\tcurr = -bc.getCheck(curr); // next\n\n\t\t\t\t// if (curr < 0) {\n\t\t\t\t//     throw 'assertion error: getCheck returns negative value'\n\t\t\t\t// }\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet empty_area_found = true;\n\t\t\tfor (let i = 0; i < children_info.length; i = i + 3) {\n\t\t\t\tconst code = children_info[i];\n\t\t\t\tconst candidate_id = _base + code;\n\n\t\t\t\tif (!this.isUnusedNode(candidate_id)) {\n\t\t\t\t\t// candidate_id is used node\n\t\t\t\t\t// next\n\t\t\t\t\tcurr = -bc.getCheck(curr);\n\t\t\t\t\t// if (curr < 0) {\n\t\t\t\t\t//     throw 'assertion error: getCheck returns negative value'\n\t\t\t\t\t// }\n\t\t\t\t\tempty_area_found = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (empty_area_found) {\n\t\t\t\t// Area is free\n\t\t\t\treturn _base;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Check this double array index is unused or not\n\t */\n\tisUnusedNode(index: number) {\n\t\tconst bc = this.bc;\n\t\tconst check = bc.getCheck(index);\n\n\t\t// if (index < 0) {\n\t\t//     throw 'assertion error: isUnusedNode index:' + index;\n\t\t// }\n\t\tif (index === ROOT_ID) {\n\t\t\t// root node\n\t\t\treturn false;\n\t\t}\n\t\tif (check < 0) {\n\t\t\t// unused\n\t\t\treturn true;\n\t\t}\n\n\t\t// used node (incl. leaf)\n\t\treturn false;\n\t}\n}\n\n/**\n * Factory method of double array\n */\nexport class DoubleArray {\n\tbc: BaseAndCheck;\n\tconstructor(bc: BaseAndCheck) {\n\t\tthis.bc = bc; // BASE and CHECK\n\t\tthis.bc.shrink();\n\t}\n\t/**\n\t * Look up a given key in this trie\n\t *\n\t * @param {String} key\n\t * @return {Boolean} True if this trie contains a given key\n\t */\n\tcontain(key: string): boolean {\n\t\tconst bc = this.bc;\n\n\t\tkey += TERM_CHAR;\n\t\tconst buffer = stringToUtf8Bytes(key);\n\n\t\tlet parent = ROOT_ID;\n\t\tlet child = NOT_FOUND;\n\n\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\tconst code = buffer[i];\n\n\t\t\tchild = this.traverse(parent, code);\n\t\t\tif (child === NOT_FOUND) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (bc.getBase(child) <= 0) {\n\t\t\t\t// leaf node\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// not leaf\n\t\t\tparent = child;\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Look up a given key in this trie\n\t *\n\t * @param {String} key\n\t * @return {Number} Record value assgned to this key, -1 if this key does not contain\n\t */\n\tlookup(key: string): number {\n\t\tkey += TERM_CHAR;\n\t\tconst buffer = stringToUtf8Bytes(key);\n\n\t\tlet parent = ROOT_ID;\n\t\tlet child = NOT_FOUND;\n\n\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\tconst code = buffer[i];\n\t\t\tchild = this.traverse(parent, code);\n\t\t\tif (child === NOT_FOUND) {\n\t\t\t\treturn NOT_FOUND;\n\t\t\t}\n\t\t\tparent = child;\n\t\t}\n\n\t\tconst base = this.bc.getBase(child);\n\t\tif (base <= 0) {\n\t\t\t// leaf node\n\t\t\treturn -base - 1;\n\t\t}\n\t\t// not leaf\n\t\treturn NOT_FOUND;\n\t}\n\t/**\n\t * Common prefix search\n\t *\n\t * @param {String} key\n\t * @return {Array} Each result object has 'k' and 'v' (key and record,\n\t * respectively) properties assigned to matched string\n\t */\n\tcommonPrefixSearch(key: string): KeyValue[] {\n\t\tconst buffer = stringToUtf8Bytes(key);\n\n\t\tlet parent = ROOT_ID;\n\t\tlet child = NOT_FOUND;\n\n\t\tconst result: KeyValue[] = [];\n\n\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\tconst code = buffer[i];\n\n\t\t\tchild = this.traverse(parent, code);\n\n\t\t\tif (child !== NOT_FOUND) {\n\t\t\t\tparent = child;\n\n\t\t\t\t// look forward by terminal character code to check this node is a leaf or not\n\t\t\t\tconst grand_child = this.traverse(child, TERM_CODE);\n\n\t\t\t\tif (grand_child !== NOT_FOUND) {\n\t\t\t\t\tconst base = this.bc.getBase(grand_child);\n\n\t\t\t\t\tconst r: KeyValue = {\n\t\t\t\t\t\tk: \"\",\n\t\t\t\t\t\tv: 0,\n\t\t\t\t\t};\n\n\t\t\t\t\tif (base <= 0) {\n\t\t\t\t\t\t// If child is a leaf node, add record to result\n\t\t\t\t\t\tr.v = -base - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If child is a leaf node, add word to result\n\t\t\t\t\tr.k = utf8BytesToString(arrayCopy(buffer, 0, i + 1));\n\n\t\t\t\t\tresult.push(r);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\ttraverse(parent: number, code: number) {\n\t\tconst child = this.bc.getBase(parent) + code;\n\t\tif (this.bc.getCheck(child) === parent) {\n\t\t\treturn child;\n\t\t}\n\t\treturn NOT_FOUND;\n\t}\n\tsize() {\n\t\treturn this.bc.size();\n\t}\n\tcalc() {\n\t\treturn this.bc.calc();\n\t}\n\tdump() {\n\t\treturn this.bc.dump();\n\t}\n}\n\n// Array utility functions\n\nconst newArrayBuffer = (signed: boolean, bytes: number, size: number) => {\n\tif (signed) {\n\t\tswitch (bytes) {\n\t\t\tcase 1:\n\t\t\t\treturn new Int8Array(size);\n\t\t\tcase 2:\n\t\t\t\treturn new Int16Array(size);\n\t\t\tcase 4:\n\t\t\t\treturn new Int32Array(size);\n\t\t\tdefault:\n\t\t\t\tthrow new RangeError(\n\t\t\t\t\t`Invalid newArray parameter element_bytes:${bytes}`,\n\t\t\t\t);\n\t\t}\n\t}\n\tswitch (bytes) {\n\t\tcase 1:\n\t\t\treturn new Uint8Array(size);\n\t\tcase 2:\n\t\t\treturn new Uint16Array(size);\n\t\tcase 4:\n\t\t\treturn new Uint32Array(size);\n\t\tdefault:\n\t\t\tthrow new RangeError(`Invalid newArray parameter element_bytes:${bytes}`);\n\t}\n};\n\nconst arrayCopy = (src: Uint8Array, src_offset: number, length: number) => {\n\tconst buffer = new ArrayBuffer(length);\n\tconst dstU8 = new Uint8Array(buffer, 0, length);\n\tconst srcU8 = src.subarray(src_offset, length);\n\tdstU8.set(srcU8);\n\treturn dstU8;\n};\n\n/**\n * Convert String (UTF-16) to UTF-8 ArrayBuffer\n *\n * @param {String} str UTF-16 string to convert\n * @return {Uint8Array} Byte sequence encoded by UTF-8\n */\nconst stringToUtf8Bytes = (str: string): Uint8Array => {\n\t// Max size of 1 character is 4 bytes\n\tconst bytes = new Uint8Array(new ArrayBuffer(str.length * 4));\n\n\tlet i = 0;\n\tlet j = 0;\n\n\twhile (i < str.length) {\n\t\tlet unicode_code: number;\n\n\t\tconst utf16_code = str.charCodeAt(i++);\n\t\tif (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n\t\t\t// surrogate pair\n\t\t\tconst upper = utf16_code; // high surrogate\n\t\t\tconst lower = str.charCodeAt(i++); // low surrogate\n\n\t\t\tif (lower >= 0xdc00 && lower <= 0xdfff) {\n\t\t\t\tunicode_code =\n\t\t\t\t\t(upper - 0xd800) * (1 << 10) + (1 << 16) + (lower - 0xdc00);\n\t\t\t} else {\n\t\t\t\t// malformed surrogate pair\n\t\t\t\tthrow new Error(\"malformed surrogate pair\");\n\t\t\t}\n\t\t} else {\n\t\t\t// not surrogate code\n\t\t\tunicode_code = utf16_code;\n\t\t}\n\n\t\tif (unicode_code < 0x80) {\n\t\t\t// 1-byte\n\t\t\tbytes[j++] = unicode_code;\n\t\t} else if (unicode_code < 1 << 11) {\n\t\t\t// 2-byte\n\t\t\tbytes[j++] = (unicode_code >>> 6) | 0xc0;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 16) {\n\t\t\t// 3-byte\n\t\t\tbytes[j++] = (unicode_code >>> 12) | 0xe0;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 21) {\n\t\t\t// 4-byte\n\t\t\tbytes[j++] = (unicode_code >>> 18) | 0xf0;\n\t\t\tbytes[j++] = ((unicode_code >> 12) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else {\n\t\t\t// malformed UCS4 code\n\t\t}\n\t}\n\n\treturn bytes.subarray(0, j);\n};\n\n/**\n * Convert UTF-8 ArrayBuffer to String (UTF-16)\n *\n * @param {Uint8Array} bytes UTF-8 byte sequence to convert\n * @return {String} String encoded by UTF-16\n */\nconst utf8BytesToString = (bytes: Uint8Array): string => {\n\tlet str = \"\";\n\tlet code: number;\n\tlet b1: number;\n\tlet b2: number;\n\tlet b3: number;\n\tlet b4: number;\n\tlet upper: number;\n\tlet lower: number;\n\tlet i = 0;\n\n\twhile (i < bytes.length) {\n\t\tb1 = bytes[i++];\n\n\t\tif (b1 < 0x80) {\n\t\t\t// 1 byte\n\t\t\tcode = b1;\n\t\t} else if (b1 >> 5 === 0x06) {\n\t\t\t// 2 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tcode = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\n\t\t} else if (b1 >> 4 === 0x0e) {\n\t\t\t// 3 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tcode = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\n\t\t} else {\n\t\t\t// 4 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tb4 = bytes[i++];\n\t\t\tcode =\n\t\t\t\t((b1 & 0x07) << 18) |\n\t\t\t\t((b2 & 0x3f) << 12) |\n\t\t\t\t((b3 & 0x3f) << 6) |\n\t\t\t\t(b4 & 0x3f);\n\t\t}\n\n\t\tif (code < 0x10000) {\n\t\t\tstr += String.fromCharCode(code);\n\t\t} else {\n\t\t\t// surrogate pair\n\t\t\tcode -= 0x10000;\n\t\t\tupper = 0xd800 | (code >> 10);\n\t\t\tlower = 0xdc00 | (code & 0x3ff);\n\t\t\tstr += String.fromCharCode(upper, lower);\n\t\t}\n\t}\n\n\treturn str;\n};\n\n// public methods\nexport function builder(initial_size: number) {\n\treturn new DoubleArrayBuilder(initial_size);\n}\nexport function load(base_buffer: Arrays, check_buffer: Arrays) {\n\tconst bc = newBC(0);\n\tbc.loadBaseBuffer(base_buffer);\n\tbc.loadCheckBuffer(check_buffer);\n\treturn new DoubleArray(bc);\n}\n","/**\n * Connection costs matrix from cc.dat file.\n * 2 dimension matrix [forward_id][backward_id] -> cost\n * @constructor\n * @param {number} forward_dimension\n * @param {number} backward_dimension\n */\nclass ConnectionCosts {\n\tbuffer: Int16Array;\n\tforward_dimension: number;\n\tbackward_dimension: number;\n\n\tconstructor(forward_dimension: number, backward_dimension: number) {\n\t\tthis.forward_dimension = forward_dimension;\n\t\tthis.backward_dimension = backward_dimension;\n\n\t\t// leading 2 integers for forward_dimension, backward_dimension, respectively\n\t\tthis.buffer = new Int16Array(forward_dimension * backward_dimension + 2);\n\t\tthis.buffer[0] = forward_dimension;\n\t\tthis.buffer[1] = backward_dimension;\n\t}\n\tput(forward_id: number, backward_id: number, cost: number) {\n\t\tconst index = forward_id * this.backward_dimension + backward_id + 2;\n\t\tif (this.buffer.length < index + 1) {\n\t\t\tthrow \"ConnectionCosts buffer overflow\";\n\t\t}\n\t\tthis.buffer[index] = cost;\n\t}\n\tget(forward_id: number, backward_id: number) {\n\t\tconst index = forward_id * this.backward_dimension + backward_id + 2;\n\t\tif (this.buffer.length < index + 1) {\n\t\t\tthrow \"ConnectionCosts buffer overflow\";\n\t\t}\n\t\treturn this.buffer[index];\n\t}\n\tloadConnectionCosts(connection_costs_buffer: Int16Array) {\n\t\tthis.forward_dimension = connection_costs_buffer[0];\n\t\tthis.backward_dimension = connection_costs_buffer[1];\n\t\tthis.buffer = connection_costs_buffer;\n\t}\n}\n\nexport default ConnectionCosts;\n","import ByteBuffer from \"../util/ByteBuffer\";\n\n/**\n * TokenInfoDictionary\n * @constructor\n */\nclass TokenInfoDictionary {\n\tdictionary: ByteBuffer;\n\ttarget_map: {\n\t\t[x: string]: (number | string)[];\n\t};\n\tpos_buffer: ByteBuffer;\n\n\tconstructor() {\n\t\tthis.dictionary = new ByteBuffer(10 * 1024 * 1024);\n\t\tthis.target_map = {}; // trie_id (of surface form) -> token_info_id (of token)\n\t\tthis.pos_buffer = new ByteBuffer(10 * 1024 * 1024);\n\t}\n\t// left_id right_id word_cost ...\n\t// ^ this position is token_info_id\n\tbuildDictionary(entries: string[][]) {\n\t\tconst dictionary_entries: { [x: number]: string } = {}; // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\n\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\tconst entry = entries[i];\n\n\t\t\tif (entry.length < 4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst surface_form = entry[0];\n\t\t\tconst left_id = Number(entry[1]);\n\t\t\tconst right_id = Number(entry[2]);\n\t\t\tconst word_cost = Number(entry[3]);\n\t\t\t// TODO: Is it OK?\n\t\t\tconst feature = entry.slice(4).join(\",\"); // TODO Optimize\n\n\t\t\t// Assertion\n\t\t\tif (\n\t\t\t\t!Number.isFinite(left_id) ||\n\t\t\t\t!Number.isFinite(right_id) ||\n\t\t\t\t!Number.isFinite(word_cost)\n\t\t\t) {\n\t\t\t\tconsole.log(entry);\n\t\t\t}\n\n\t\t\tconst token_info_id = this.put(\n\t\t\t\tleft_id,\n\t\t\t\tright_id,\n\t\t\t\tword_cost,\n\t\t\t\tsurface_form,\n\t\t\t\tfeature,\n\t\t\t);\n\t\t\tdictionary_entries[token_info_id] = surface_form;\n\t\t}\n\n\t\t// Remove last unused area\n\t\tthis.dictionary.shrink();\n\t\tthis.pos_buffer.shrink();\n\n\t\treturn dictionary_entries;\n\t}\n\tput(\n\t\tleft_id: number,\n\t\tright_id: number,\n\t\tword_cost: number,\n\t\tsurface_form: string,\n\t\tfeature: string,\n\t) {\n\t\tconst token_info_id = this.dictionary.position;\n\t\tconst pos_id = this.pos_buffer.position;\n\n\t\tthis.dictionary.putShort(left_id);\n\t\tthis.dictionary.putShort(right_id);\n\t\tthis.dictionary.putShort(word_cost);\n\t\tthis.dictionary.putInt(pos_id);\n\t\tthis.pos_buffer.putString(`${surface_form},${feature}`);\n\n\t\treturn token_info_id;\n\t}\n\taddMapping(source: number, target: number | string) {\n\t\tlet mapping = this.target_map[source];\n\t\tif (mapping == null) {\n\t\t\tmapping = [];\n\t\t}\n\t\tmapping.push(target);\n\n\t\tthis.target_map[source] = mapping;\n\t}\n\ttargetMapToBuffer() {\n\t\tconst buffer = new ByteBuffer();\n\t\tconst map_keys_size = Object.keys(this.target_map).length;\n\t\tbuffer.putInt(map_keys_size);\n\t\tfor (const key in this.target_map) {\n\t\t\tconst values = this.target_map[key]; // Array\n\t\t\tconst map_values_size = values.length;\n\t\t\tbuffer.putInt(Number.parseInt(key));\n\t\t\tbuffer.putInt(map_values_size);\n\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\tbuffer.putInt(values[i]);\n\t\t\t}\n\t\t}\n\t\treturn buffer.shrink(); // Shrink-ed Typed Array\n\t}\n\t// from tid.dat\n\tloadDictionary(array_buffer?: Uint8Array<ArrayBufferLike>) {\n\t\tthis.dictionary = new ByteBuffer(array_buffer);\n\t\treturn this;\n\t}\n\t// from tid_pos.dat\n\tloadPosVector(array_buffer?: Uint8Array<ArrayBufferLike>) {\n\t\tthis.pos_buffer = new ByteBuffer(array_buffer);\n\t\treturn this;\n\t}\n\t// from tid_map.dat\n\tloadTargetMap(array_buffer?: Uint8Array<ArrayBufferLike>) {\n\t\tconst buffer = new ByteBuffer(array_buffer);\n\t\tbuffer.position = 0;\n\t\tthis.target_map = {};\n\t\tbuffer.readInt(); // map_keys_size\n\t\twhile (true) {\n\t\t\tif (buffer.buffer.length < buffer.position + 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst key = buffer.readInt();\n\t\t\tconst map_values_size = buffer.readInt();\n\t\t\tfor (let i = 0; i < map_values_size; i++) {\n\t\t\t\tconst value = buffer.readInt();\n\t\t\t\tthis.addMapping(key, value);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Look up features in the dictionary\n\t * @param {string} token_info_id_str Word ID to look up\n\t * @returns {string} Features string concatenated by \",\"\n\t */\n\tgetFeatures(token_info_id_str: string): string {\n\t\tconst token_info_id = Number.parseInt(token_info_id_str);\n\t\tif (Number.isNaN(token_info_id)) {\n\t\t\t// TODO throw error\n\t\t\treturn \"\";\n\t\t}\n\t\tconst pos_id = this.dictionary.getInt(token_info_id + 6);\n\t\treturn this.pos_buffer.getString(pos_id);\n\t}\n}\n\nexport default TokenInfoDictionary;\n","/**\n * Convert String (UTF-16) to UTF-8 ArrayBuffer\n *\n * @param {String} str UTF-16 string to convert\n * @return {Uint8Array} Byte sequence encoded by UTF-8\n */\nconst stringToUtf8Bytes = (str: string): Uint8Array => {\n\t// Max size of 1 character is 4 bytes\n\tconst bytes = new Uint8Array(str.length * 4);\n\n\tlet i = 0;\n\tlet j = 0;\n\n\twhile (i < str.length) {\n\t\tlet unicode_code: number;\n\n\t\tconst utf16_code = str.charCodeAt(i++);\n\t\tif (utf16_code >= 0xd800 && utf16_code <= 0xdbff) {\n\t\t\t// surrogate pair\n\t\t\tconst upper = utf16_code; // high surrogate\n\t\t\tconst lower = str.charCodeAt(i++); // low surrogate\n\n\t\t\tif (lower >= 0xdc00 && lower <= 0xdfff) {\n\t\t\t\tunicode_code =\n\t\t\t\t\t(upper - 0xd800) * (1 << 10) + (1 << 16) + (lower - 0xdc00);\n\t\t\t} else {\n\t\t\t\t// malformed surrogate pair\n\t\t\t\tthrow new Error(\"malformed surrogate pair\");\n\t\t\t}\n\t\t} else {\n\t\t\t// not surrogate code\n\t\t\tunicode_code = utf16_code;\n\t\t}\n\n\t\tif (unicode_code < 0x80) {\n\t\t\t// 1-byte\n\t\t\tbytes[j++] = unicode_code;\n\t\t} else if (unicode_code < 1 << 11) {\n\t\t\t// 2-byte\n\t\t\tbytes[j++] = (unicode_code >>> 6) | 0xc0;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 16) {\n\t\t\t// 3-byte\n\t\t\tbytes[j++] = (unicode_code >>> 12) | 0xe0;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else if (unicode_code < 1 << 21) {\n\t\t\t// 4-byte\n\t\t\tbytes[j++] = (unicode_code >>> 18) | 0xf0;\n\t\t\tbytes[j++] = ((unicode_code >> 12) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n\t\t\tbytes[j++] = (unicode_code & 0x3f) | 0x80;\n\t\t} else {\n\t\t\t// malformed UCS4 code\n\t\t}\n\t}\n\n\treturn bytes.subarray(0, j);\n};\n\n/**\n * Convert UTF-8 ArrayBuffer to String (UTF-16)\n *\n * @param {Array} bytes UTF-8 byte sequence to convert\n * @return {String} String encoded by UTF-16\n */\nconst utf8BytesToString = (bytes: number[]): string => {\n\tlet str = \"\";\n\tlet code: number;\n\tlet b1: number;\n\tlet b2: number;\n\tlet b3: number;\n\tlet b4: number;\n\tlet upper: number;\n\tlet lower: number;\n\tlet i = 0;\n\n\twhile (i < bytes.length) {\n\t\tb1 = bytes[i++];\n\n\t\tif (b1 < 0x80) {\n\t\t\t// 1 byte\n\t\t\tcode = b1;\n\t\t} else if (b1 >> 5 === 0x06) {\n\t\t\t// 2 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tcode = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\n\t\t} else if (b1 >> 4 === 0x0e) {\n\t\t\t// 3 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tcode = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\n\t\t} else {\n\t\t\t// 4 bytes\n\t\t\tb2 = bytes[i++];\n\t\t\tb3 = bytes[i++];\n\t\t\tb4 = bytes[i++];\n\t\t\tcode =\n\t\t\t\t((b1 & 0x07) << 18) |\n\t\t\t\t((b2 & 0x3f) << 12) |\n\t\t\t\t((b3 & 0x3f) << 6) |\n\t\t\t\t(b4 & 0x3f);\n\t\t}\n\n\t\tif (code < 0x10000) {\n\t\t\tstr += String.fromCharCode(code);\n\t\t} else {\n\t\t\t// surrogate pair\n\t\t\tcode -= 0x10000;\n\t\t\tupper = 0xd800 | (code >> 10);\n\t\t\tlower = 0xdc00 | (code & 0x3ff);\n\t\t\tstr += String.fromCharCode(upper, lower);\n\t\t}\n\t}\n\n\treturn str;\n};\n\n/**\n * Utilities to manipulate byte sequence\n * @param {(number|Uint8Array)} arg Initial size of this buffer (number), or buffer to set (Uint8Array)\n * @constructor\n */\nclass ByteBuffer {\n\tbuffer: Uint8Array<ArrayBufferLike>;\n\tposition: number;\n\tconstructor(arg?: number | Uint8Array) {\n\t\tlet initial_size: number;\n\t\tif (arg == null) {\n\t\t\tinitial_size = 1024 * 1024;\n\t\t} else if (typeof arg === \"number\") {\n\t\t\tinitial_size = arg;\n\t\t} else if (arg instanceof Uint8Array) {\n\t\t\tthis.buffer = arg;\n\t\t\tthis.position = 0; // Overwrite\n\t\t\treturn;\n\t\t} else {\n\t\t\t// typeof arg -> String\n\t\t\tthrow `${typeof arg} is invalid parameter type for ByteBuffer constructor`;\n\t\t}\n\t\t// arg is null or number\n\t\tthis.buffer = new Uint8Array(initial_size);\n\t\tthis.position = 0;\n\t}\n\tsize() {\n\t\treturn this.buffer.length;\n\t}\n\treallocate() {\n\t\tconst new_array = new Uint8Array(this.buffer.length * 2);\n\t\tnew_array.set(this.buffer);\n\t\tthis.buffer = new_array;\n\t}\n\tshrink() {\n\t\tthis.buffer = this.buffer.subarray(0, this.position);\n\t\treturn this.buffer;\n\t}\n\tput(b: number) {\n\t\tif (this.buffer.length < this.position + 1) {\n\t\t\tthis.reallocate();\n\t\t}\n\t\tthis.buffer[this.position++] = b;\n\t}\n\tget(index?: number) {\n\t\tif (index == null) {\n\t\t\tindex = this.position;\n\t\t\tthis.position += 1;\n\t\t}\n\t\tif (this.buffer.length < index + 1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.buffer[index];\n\t}\n\t// Write short to buffer by little endian\n\tputShort(num: string | number) {\n\t\tnum = Number(num);\n\t\tif (0xffff < num) {\n\t\t\tthrow `${num} is over short value`;\n\t\t}\n\t\tconst lower = 0x00ff & num;\n\t\tconst upper = (0xff00 & num) >> 8;\n\t\tthis.put(lower);\n\t\tthis.put(upper);\n\t}\n\t// Read short from buffer by little endian\n\tgetShort(index?: number) {\n\t\tif (index == null) {\n\t\t\tindex = this.position;\n\t\t\tthis.position += 2;\n\t\t}\n\t\tif (this.buffer.length < index + 2) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst lower = this.buffer[index];\n\t\tconst upper = this.buffer[index + 1];\n\t\tlet value = (upper << 8) + lower;\n\t\tif (value & 0x8000) {\n\t\t\tvalue = -((value - 1) ^ 0xffff);\n\t\t}\n\t\treturn value;\n\t}\n\t// Write integer to buffer by little endian\n\tputInt(num: string | number) {\n\t\tnum = Number(num);\n\t\tif (0xffffffff < num) {\n\t\t\tthrow `${num} is over integer value`;\n\t\t}\n\t\tconst b0 = 0x000000ff & num;\n\t\tconst b1 = (0x0000ff00 & num) >> 8;\n\t\tconst b2 = (0x00ff0000 & num) >> 16;\n\t\tconst b3 = (0xff000000 & num) >> 24;\n\t\tthis.put(b0);\n\t\tthis.put(b1);\n\t\tthis.put(b2);\n\t\tthis.put(b3);\n\t}\n\t// Read integer from buffer by little endian\n\tgetInt(index?: number) {\n\t\tif (index == null) {\n\t\t\tindex = this.position;\n\t\t\tthis.position += 4;\n\t\t}\n\t\tif (this.buffer.length < index + 4) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst b0 = this.buffer[index];\n\t\tconst b1 = this.buffer[index + 1];\n\t\tconst b2 = this.buffer[index + 2];\n\t\tconst b3 = this.buffer[index + 3];\n\n\t\treturn (b3 << 24) + (b2 << 16) + (b1 << 8) + b0;\n\t}\n\treadInt() {\n\t\tconst pos = this.position;\n\t\tthis.position += 4;\n\t\treturn this.getInt(pos);\n\t}\n\tputString(str: string) {\n\t\tconst bytes = stringToUtf8Bytes(str);\n\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\tthis.put(bytes[i]);\n\t\t}\n\t\t// put null character as terminal character\n\t\tthis.put(0);\n\t}\n\tgetString(index = this.position) {\n\t\tconst buf: number[] = [];\n\t\tlet ch: number;\n\t\twhile (true) {\n\t\t\tif (this.buffer.length < index + 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = this.get(index++);\n\t\t\tif (ch === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf.push(ch);\n\t\t}\n\t\tthis.position = index;\n\t\treturn utf8BytesToString(buf);\n\t}\n}\n\nexport default ByteBuffer;\n","import ByteBuffer from \"../util/ByteBuffer\";\nimport CharacterDefinition from \"./CharacterDefinition\";\nimport type InvokeDefinitionMap from \"./InvokeDefinitionMap\";\nimport TokenInfoDictionary from \"./TokenInfoDictionary\";\n\n/**\n * UnknownDictionary\n * @constructor\n */\n// Inherit from TokenInfoDictionary as a super class\nclass UnknownDictionary extends TokenInfoDictionary {\n\tcharacter_definition?: CharacterDefinition;\n\tconstructor() {\n\t\tsuper();\n\t\tthis.dictionary = new ByteBuffer(10 * 1024 * 1024);\n\t\tthis.target_map = {}; // class_id (of CharacterClass) -> token_info_id (of unknown class)\n\t\tthis.pos_buffer = new ByteBuffer(10 * 1024 * 1024);\n\t}\n\tcharacterDefinition(character_definition: CharacterDefinition) {\n\t\tthis.character_definition = character_definition;\n\t\treturn this;\n\t}\n\tlookup(ch: string) {\n\t\tif (!this.character_definition) {\n\t\t\tthrow new Error(\"Character definition is not initialized\");\n\t\t}\n\t\treturn this.character_definition.lookup(ch);\n\t}\n\tlookupCompatibleCategory(ch: string) {\n\t\tif (!this.character_definition) {\n\t\t\tthrow new Error(\"Character definition is not initialized\");\n\t\t}\n\t\treturn this.character_definition.lookupCompatibleCategory(ch);\n\t}\n\tloadUnknownDictionaries(\n\t\tunk_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_pos_buffer: Uint8Array<ArrayBufferLike>,\n\t\tunk_map_buffer: Uint8Array<ArrayBufferLike>,\n\t\tcat_map_buffer: Uint8Array,\n\t\tcompat_cat_map_buffer: Uint32Array,\n\t\tinvoke_def_buffer: Uint8Array,\n\t) {\n\t\tthis.loadDictionary(unk_buffer);\n\t\tthis.loadPosVector(unk_pos_buffer);\n\t\tthis.loadTargetMap(unk_map_buffer);\n\t\tthis.character_definition = CharacterDefinition.load(\n\t\t\tcat_map_buffer,\n\t\t\tcompat_cat_map_buffer,\n\t\t\tinvoke_def_buffer,\n\t\t);\n\t}\n}\n\nexport default UnknownDictionary;\n","import SurrogateAwareString from \"../util/SurrogateAwareString\";\nimport CharacterClass from \"./CharacterClass\";\nimport InvokeDefinitionMap from \"./InvokeDefinitionMap\";\n\nconst DEFAULT_CATEGORY = \"DEFAULT\";\n\n/**\n * CharacterDefinition represents char.def file and\n * defines behavior of unknown word processing\n * @constructor\n */\nclass CharacterDefinition {\n\tcharacter_category_map: Uint8Array;\n\tcompatible_category_map: Uint32Array;\n\tinvoke_definition_map?: InvokeDefinitionMap;\n\n\tconstructor() {\n\t\tthis.character_category_map = new Uint8Array(65536); // for all UCS2 code points\n\t\tthis.compatible_category_map = new Uint32Array(65536); // for all UCS2 code points\n\t}\n\t/**\n\t * Load CharacterDefinition\n\t * @param {Uint8Array} cat_map_buffer\n\t * @param {Uint32Array} compat_cat_map_buffer\n\t * @param {InvokeDefinitionMap} invoke_def_buffer\n\t * @returns {CharacterDefinition}\n\t */\n\tstatic load(\n\t\tcat_map_buffer: Uint8Array,\n\t\tcompat_cat_map_buffer: Uint32Array,\n\t\tinvoke_def_buffer: Uint8Array,\n\t): CharacterDefinition {\n\t\tconst char_def = new CharacterDefinition();\n\t\tchar_def.character_category_map = cat_map_buffer;\n\t\tchar_def.compatible_category_map = compat_cat_map_buffer;\n\t\tchar_def.invoke_definition_map =\n\t\t\tInvokeDefinitionMap.load(invoke_def_buffer);\n\t\treturn char_def;\n\t}\n\tstatic parseCharCategory(class_id: number, parsed_category_def: string[]) {\n\t\tconst category = parsed_category_def[1];\n\t\tconst invoke = Number.parseInt(parsed_category_def[2]);\n\t\tconst grouping = Number.parseInt(parsed_category_def[3]);\n\t\tconst max_length = Number.parseInt(parsed_category_def[4]);\n\t\tif (!Number.isFinite(invoke) || (invoke !== 0 && invoke !== 1)) {\n\t\t\tconsole.log(`char.def parse error. INVOKE is 0 or 1 in:${invoke}`);\n\t\t\treturn null;\n\t\t}\n\t\tif (!Number.isFinite(grouping) || (grouping !== 0 && grouping !== 1)) {\n\t\t\tconsole.log(`char.def parse error. GROUP is 0 or 1 in:${grouping}`);\n\t\t\treturn null;\n\t\t}\n\t\tif (!Number.isFinite(max_length) || max_length < 0) {\n\t\t\tconsole.log(`char.def parse error. LENGTH is 1 to n:${max_length}`);\n\t\t\treturn null;\n\t\t}\n\t\tconst is_invoke = invoke === 1;\n\t\tconst is_grouping = grouping === 1;\n\n\t\treturn new CharacterClass(\n\t\t\tclass_id,\n\t\t\tcategory,\n\t\t\tis_invoke,\n\t\t\tis_grouping,\n\t\t\tmax_length,\n\t\t);\n\t}\n\tstatic parseCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n\t\tconst start = Number.parseInt(parsed_category_mapping[1]);\n\t\tconst default_category = parsed_category_mapping[2];\n\t\tconst compatible_category =\n\t\t\t3 < parsed_category_mapping.length\n\t\t\t\t? parsed_category_mapping.slice(3)\n\t\t\t\t: [];\n\t\tif (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n\t\t\tconsole.log(`char.def parse error. CODE is invalid:${start}`);\n\t\t}\n\t\treturn {\n\t\t\tstart: start,\n\t\t\tdefault: default_category,\n\t\t\tcompatible: compatible_category,\n\t\t};\n\t}\n\tstatic parseRangeCategoryMapping(parsed_category_mapping: RegExpExecArray) {\n\t\tconst start = Number.parseInt(parsed_category_mapping[1]);\n\t\tconst end = Number.parseInt(parsed_category_mapping[2]);\n\t\tconst default_category = parsed_category_mapping[3];\n\t\tconst compatible_category =\n\t\t\t4 < parsed_category_mapping.length\n\t\t\t\t? parsed_category_mapping.slice(4)\n\t\t\t\t: [];\n\t\tif (!Number.isFinite(start) || start < 0 || start > 0xffff) {\n\t\t\tconsole.log(`char.def parse error. CODE is invalid:${start}`);\n\t\t}\n\t\tif (!Number.isFinite(end) || end < 0 || end > 0xffff) {\n\t\t\tconsole.log(`char.def parse error. CODE is invalid:${end}`);\n\t\t}\n\t\treturn {\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tdefault: default_category,\n\t\t\tcompatible: compatible_category,\n\t\t};\n\t}\n\t/**\n\t * Initializing method\n\t * @param {Array} category_mapping Array of category mapping\n\t */\n\tinitCategoryMappings(\n\t\tcategory_mapping: {\n\t\t\tstart: number;\n\t\t\tend?: number;\n\t\t\tdefault: string;\n\t\t\tcompatible: string[];\n\t\t}[],\n\t) {\n\t\tif (!this.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\t// Initialize map by DEFAULT class\n\t\tlet code_point: number;\n\t\tif (category_mapping != null) {\n\t\t\tfor (let i = 0; i < category_mapping.length; i++) {\n\t\t\t\tconst mapping = category_mapping[i];\n\t\t\t\tconst end = mapping.end || mapping.start;\n\t\t\t\tfor (code_point = mapping.start; code_point <= end; code_point++) {\n\t\t\t\t\t// Default Category class ID\n\t\t\t\t\tthis.character_category_map[code_point] =\n\t\t\t\t\t\tthis.invoke_definition_map.lookup(mapping.default);\n\n\t\t\t\t\tfor (let j = 0; j < mapping.compatible.length; j++) {\n\t\t\t\t\t\tlet bitset = this.compatible_category_map[code_point];\n\t\t\t\t\t\tconst compatible_category = mapping.compatible[j];\n\t\t\t\t\t\tif (compatible_category == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst class_id =\n\t\t\t\t\t\t\tthis.invoke_definition_map.lookup(compatible_category); // Default Category\n\t\t\t\t\t\tif (class_id == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst class_id_bit = 1 << class_id;\n\t\t\t\t\t\tbitset = bitset | class_id_bit; // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n\t\t\t\t\t\tthis.compatible_category_map[code_point] = bitset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n\t\tif (default_id == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (\n\t\t\tcode_point = 0;\n\t\t\tcode_point < this.character_category_map.length;\n\t\t\tcode_point++\n\t\t) {\n\t\t\t// 他に何のクラスも定義されていなかったときだけ DEFAULT\n\t\t\tif (this.character_category_map[code_point] === 0) {\n\t\t\t\t// DEFAULT class ID に対応するビットだけ1を立てる\n\t\t\t\tthis.character_category_map[code_point] = 1 << default_id;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Lookup compatible categories for a character (not included 1st category)\n\t * @param {string} ch UCS2 character (just 1st character is effective)\n\t * @returns {Array.<CharacterClass>} character classes\n\t */\n\tlookupCompatibleCategory(ch: string): CharacterClass[] {\n\t\tif (!this.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\tconst classes: CharacterClass[] = [];\n\n\t\t/*\n         if (SurrogateAwareString.isSurrogatePair(ch)) {\n         // Surrogate pair character codes can not be defined by char.def\n         return classes;\n         }*/\n\t\tconst code = ch.charCodeAt(0);\n\t\tlet integer: number | undefined = undefined;\n\t\tif (code < this.compatible_category_map.length) {\n\t\t\tinteger = this.compatible_category_map[code]; // Bitset\n\t\t}\n\n\t\tif (integer == null || integer === 0) {\n\t\t\treturn classes;\n\t\t}\n\n\t\tfor (let bit = 0; bit < 32; bit++) {\n\t\t\t// Treat \"bit\" as a class ID\n\t\t\tif ((integer << (31 - bit)) >>> 31 === 1) {\n\t\t\t\tconst character_class =\n\t\t\t\t\tthis.invoke_definition_map.getCharacterClass(bit);\n\t\t\t\tif (character_class == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclasses.push(character_class);\n\t\t\t}\n\t\t}\n\t\treturn classes;\n\t}\n\t/**\n\t * Lookup category for a character\n\t * @param {string} ch UCS2 character (just 1st character is effective)\n\t * @returns {CharacterClass} character class\n\t */\n\tlookup(ch: string): CharacterClass {\n\t\tif (!this.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\tlet class_id: number | undefined;\n\n\t\tconst code = ch.charCodeAt(0);\n\t\tif (SurrogateAwareString.isSurrogatePair(ch)) {\n\t\t\t// Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n\t\t\tclass_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n\t\t} else if (code < this.character_category_map.length) {\n\t\t\tclass_id = this.character_category_map[code]; // Read as integer value\n\t\t}\n\n\t\tif (class_id == null) {\n\t\t\tclass_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n\t\t}\n\n\t\treturn this.invoke_definition_map.getCharacterClass(class_id);\n\t}\n}\n\nexport default CharacterDefinition;\n","/**\n * CharacterClass\n * @param {number} class_id\n * @param {string} class_name\n * @param {boolean} is_always_invoke\n * @param {boolean} is_grouping\n * @param {number} max_length\n * @constructor\n */\nclass CharacterClass {\n\tclass_id: number;\n\tclass_name: string;\n\tis_always_invoke: boolean;\n\tis_grouping: boolean;\n\tmax_length: number;\n\tconstructor(\n\t\tclass_id: number,\n\t\tclass_name: string,\n\t\tis_always_invoke: boolean,\n\t\tis_grouping: boolean,\n\t\tmax_length: number,\n\t) {\n\t\tthis.class_id = class_id;\n\t\tthis.class_name = class_name;\n\t\tthis.is_always_invoke = is_always_invoke;\n\t\tthis.is_grouping = is_grouping;\n\t\tthis.max_length = max_length;\n\t}\n}\n\nexport default CharacterClass;\n","import ByteBuffer from \"../util/ByteBuffer\";\nimport CharacterClass from \"./CharacterClass\";\n\n/**\n * InvokeDefinitionMap represents invoke definition a part of char.def\n * @constructor\n */\nclass InvokeDefinitionMap {\n\tmap: CharacterClass[];\n\tlookup_table: { [x: string]: number };\n\n\tconstructor() {\n\t\tthis.map = [];\n\t\tthis.lookup_table = {}; // Just for building dictionary\n\t}\n\t/**\n\t * Load InvokeDefinitionMap from buffer\n\t * @param {Uint8Array} invoke_def_buffer\n\t * @returns {InvokeDefinitionMap}\n\t */\n\tstatic load(invoke_def_buffer: Uint8Array): InvokeDefinitionMap {\n\t\tconst invoke_def = new InvokeDefinitionMap();\n\t\tconst character_category_definition: CharacterClass[] = [];\n\n\t\tconst buffer = new ByteBuffer(invoke_def_buffer);\n\t\twhile (buffer.position + 1 < buffer.size()) {\n\t\t\tconst class_id = character_category_definition.length;\n\t\t\tconst is_always_invoke = buffer.get() === 1;\n\t\t\tconst is_grouping = buffer.get() === 1;\n\t\t\tconst max_length = buffer.getInt();\n\t\t\tconst class_name = buffer.getString();\n\t\t\tcharacter_category_definition.push(\n\t\t\t\tnew CharacterClass(\n\t\t\t\t\tclass_id,\n\t\t\t\t\tclass_name,\n\t\t\t\t\tis_always_invoke,\n\t\t\t\t\tis_grouping,\n\t\t\t\t\tmax_length,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tinvoke_def.init(character_category_definition);\n\n\t\treturn invoke_def;\n\t}\n\t/**\n\t * Initializing method\n\t * @param {Array.<CharacterClass>} character_category_definition Array of CharacterClass\n\t */\n\tinit(character_category_definition: CharacterClass[]) {\n\t\tif (character_category_definition == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < character_category_definition.length; i++) {\n\t\t\tconst character_class = character_category_definition[i];\n\t\t\tthis.map[i] = character_class;\n\t\t\tthis.lookup_table[character_class.class_name] = i;\n\t\t}\n\t}\n\t/**\n\t * Get class information by class ID\n\t * @param {number} class_id\n\t * @returns {CharacterClass}\n\t */\n\tgetCharacterClass(class_id: number): CharacterClass {\n\t\treturn this.map[class_id];\n\t}\n\t/**\n\t * For building character definition dictionary\n\t * @param {string} class_name character\n\t * @returns {number} class_id\n\t */\n\tlookup(class_name: string): number {\n\t\tconst class_id = this.lookup_table[class_name];\n\t\tif (class_id == null) {\n\t\t\tthrow new Error(\"null\");\n\t\t}\n\t\treturn class_id;\n\t}\n\t/**\n\t * Transform from map to binary buffer\n\t * @returns {Uint8Array}\n\t */\n\ttoBuffer(): Uint8Array {\n\t\tconst buffer = new ByteBuffer();\n\t\tfor (let i = 0; i < this.map.length; i++) {\n\t\t\tconst char_class = this.map[i];\n\t\t\tbuffer.put(Number(char_class.is_always_invoke));\n\t\t\tbuffer.put(Number(char_class.is_grouping));\n\t\t\tbuffer.putInt(char_class.max_length);\n\t\t\tbuffer.putString(char_class.class_name);\n\t\t}\n\t\tbuffer.shrink();\n\t\treturn buffer.buffer;\n\t}\n}\n\nexport default InvokeDefinitionMap;\n","import type { Token, Formatter } from \"./Formatter\";\n\n/**\n * Mappings between IPADIC dictionary features and tokenized results\n * @constructor\n */\nclass IpadicFormatter implements Formatter {\n\tformatEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t) {\n\t\tconst token: Token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: features[0],\n\t\t\tpos: features[1],\n\t\t\tpos_detail_1: features[2],\n\t\t\tpos_detail_2: features[3],\n\t\t\tpos_detail_3: features[4],\n\t\t\tconjugated_type: features[5],\n\t\t\tconjugated_form: features[6],\n\t\t\tbasic_form: features[7],\n\t\t\treading: features[8],\n\t\t\tpronunciation: features[9],\n\t\t};\n\n\t\treturn token;\n\t}\n\tformatUnknownEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t\tsurface_form: string,\n\t) {\n\t\tconst token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: surface_form,\n\t\t\tpos: features[1],\n\t\t\tpos_detail_1: features[2],\n\t\t\tpos_detail_2: features[3],\n\t\t\tpos_detail_3: features[4],\n\t\t\tconjugated_type: features[5],\n\t\t\tconjugated_form: features[6],\n\t\t\tbasic_form: features[7],\n\t\t\t// reading:features[8],\n\t\t\t// pronunciation:features[9],\n\t\t};\n\n\t\treturn token;\n\t}\n}\n\nexport default IpadicFormatter;\n","import type { Formatter, Token } from \"./Formatter\";\n\n/**\n * Mappings between Unidic dictionary features and tokenized results\n * @constructor\n */\nclass UnidicFormatter implements Formatter {\n\tformatEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t) {\n\t\tconst token: Token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: features[1],\n\t\t\tpos: features[2],\n\t\t\tpos_detail_1: features[3],\n\t\t\tpos_detail_2: features[4],\n\t\t\tpos_detail_3: features[5],\n\t\t\tconjugated_type: features[6],\n\t\t\tconjugated_form: features[7],\n\t\t\tbasic_form: features[9],\n\t\t\treading: features[8],\n\t\t};\n\n\t\treturn token;\n\t}\n\tformatUnknownEntry(\n\t\tword_id: number,\n\t\tposition: number,\n\t\ttype: string,\n\t\tfeatures: string[],\n\t\tsurface_form: string,\n\t) {\n\t\tconst token = {\n\t\t\tword_id: word_id,\n\t\t\tword_type: type,\n\t\t\tword_position: position,\n\n\t\t\tsurface_form: surface_form,\n\t\t\tpos: features[2],\n\t\t\tpos_detail_1: features[3],\n\t\t\tpos_detail_2: features[4],\n\t\t\tpos_detail_3: features[5],\n\t\t\tconjugated_type: features[6],\n\t\t\tconjugated_form: features[7],\n\t\t\tbasic_form: features[10],\n\t\t\t// reading: features[11],\n\t\t};\n\n\t\treturn token;\n\t}\n}\n\nexport default UnidicFormatter;\n","import { type DoubleArray, builder as _builder } from \"../../util/DoubleArray\";\nimport DynamicDictionaries from \"../DynamicDictionaries\";\nimport TokenInfoDictionary from \"../TokenInfoDictionary\";\nimport UnknownDictionary from \"../UnknownDictionary\";\nimport CharacterDefinitionBuilder from \"./CharacterDefinitionBuilder\";\nimport ConnectionCostsBuilder from \"./ConnectionCostsBuilder\";\n\n/**\n * Build dictionaries (token info, connection costs)\n *\n * Generates from matrix.def\n * cc.dat: Connection costs\n *\n * Generates from *.csv\n * dat.dat: Double array\n * tid.dat: Token info dictionary\n * tid_map.dat: targetMap\n * tid_pos.dat: posList (part of speech)\n */\nclass DictionaryBuilder {\n\ttid_entries: string[][];\n\tunk_entries: string[][];\n\tcc_builder: ConnectionCostsBuilder;\n\tcd_builder: CharacterDefinitionBuilder;\n\tconstructor() {\n\t\t// Array of entries, each entry in Mecab form\n\t\t// (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n\t\tthis.tid_entries = [];\n\t\tthis.unk_entries = [];\n\t\tthis.cc_builder = new ConnectionCostsBuilder();\n\t\tthis.cd_builder = new CharacterDefinitionBuilder();\n\t}\n\taddTokenInfoDictionary(new_entry: string[]) {\n\t\tthis.tid_entries.push(new_entry);\n\t\treturn this;\n\t}\n\t/**\n\t * Put one line of \"matrix.def\" file for building ConnectionCosts object\n\t * @param {string} line is a line of \"matrix.def\"\n\t */\n\tputCostMatrixLine(line: string) {\n\t\tthis.cc_builder.putLine(line);\n\t\treturn this;\n\t}\n\tputCharDefLine(line: string) {\n\t\tthis.cd_builder.putLine(line);\n\t\treturn this;\n\t}\n\t/**\n\t * Put one line of \"unk.def\" file for building UnknownDictionary object\n\t * @param {string[]} new_entry is a line of \"unk.def\"\n\t */\n\tputUnkDefLine(new_entry: string[]) {\n\t\tthis.unk_entries.push(new_entry);\n\t\treturn this;\n\t}\n\tbuild() {\n\t\tconst dictionaries = this.buildTokenInfoDictionary();\n\t\tconst unknown_dictionary = this.buildUnknownDictionary();\n\n\t\treturn new DynamicDictionaries(\n\t\t\tdictionaries.trie,\n\t\t\tdictionaries.token_info_dictionary,\n\t\t\tthis.cc_builder.build(),\n\t\t\tunknown_dictionary,\n\t\t);\n\t}\n\t/**\n\t * Build TokenInfoDictionary\n\t *\n\t * @returns {{trie: DoubleArray, token_info_dictionary: TokenInfoDictionary}}\n\t */\n\tbuildTokenInfoDictionary(): { trie: DoubleArray; token_info_dictionary: TokenInfoDictionary; } {\n\t\tconst token_info_dictionary = new TokenInfoDictionary();\n\n\t\t// using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\t\tconst dictionary_entries = token_info_dictionary.buildDictionary(\n\t\t\tthis.tid_entries,\n\t\t);\n\n\t\tconst trie = this.buildDoubleArray();\n\n\t\tfor (const token_info_id in dictionary_entries) {\n\t\t\tconst surface_form = dictionary_entries[token_info_id];\n\t\t\tconst trie_id = trie.lookup(surface_form);\n\n\t\t\t// Assertion\n\t\t\t// if (trie_id < 0) {\n\t\t\t//     console.log(\"Not Found:\" + surface_form);\n\t\t\t// }\n\t\t\ttoken_info_dictionary.addMapping(trie_id, token_info_id);\n\t\t}\n\n\t\treturn {\n\t\t\ttrie: trie,\n\t\t\ttoken_info_dictionary: token_info_dictionary,\n\t\t};\n\t}\n\tbuildUnknownDictionary() {\n\t\tconst unk_dictionary = new UnknownDictionary();\n\n\t\t// using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\t\tconst dictionary_entries = unk_dictionary.buildDictionary(this.unk_entries);\n\n\t\tconst char_def = this.cd_builder.build(); // Create CharacterDefinition\n\n\t\tif (!char_def.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\n\t\tunk_dictionary.characterDefinition(char_def);\n\n\t\tfor (const token_info_id in dictionary_entries) {\n\t\t\tconst class_name = dictionary_entries[token_info_id];\n\t\t\tconst class_id = char_def.invoke_definition_map.lookup(class_name);\n\n\t\t\t// Assertion\n\t\t\t// if (trie_id < 0) {\n\t\t\t//     console.log(\"Not Found:\" + surface_form);\n\t\t\t// }\n\t\t\tunk_dictionary.addMapping(class_id, token_info_id);\n\t\t}\n\n\t\treturn unk_dictionary;\n\t}\n\t/**\n\t * Build double array trie\n\t *\n\t * @returns {DoubleArray} Double-Array trie\n\t */\n\tbuildDoubleArray(): DoubleArray {\n\t\tlet trie_id = 0;\n\t\tconst words = this.tid_entries.map((entry) => {\n\t\t\tconst surface_form = entry[0];\n\t\t\treturn { k: surface_form, v: trie_id++ };\n\t\t});\n\n\t\tconst builder = _builder(1024 * 1024);\n\t\treturn builder.build(words);\n\t}\n}\n\nexport default DictionaryBuilder;\n","import type CharacterClass from \"../CharacterClass\";\nimport CharacterDefinition from \"../CharacterDefinition\";\nimport InvokeDefinitionMap from \"../InvokeDefinitionMap\";\n\nconst CATEGORY_DEF_PATTERN = /^(\\w+)\\s+(\\d)\\s+(\\d)\\s+(\\d)/;\nconst CATEGORY_MAPPING_PATTERN =\n\t/^(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\nconst RANGE_CATEGORY_MAPPING_PATTERN =\n\t/^(0x[0-9A-F]{4})\\.\\.(0x[0-9A-F]{4})(?:\\s+([^#\\s]+))(?:\\s+([^#\\s]+))*/;\n\n/**\n * CharacterDefinitionBuilder\n * @constructor\n */\nclass CharacterDefinitionBuilder {\n\tchar_def: CharacterDefinition;\n\tcharacter_category_definition: CharacterClass[];\n\tcategory_mapping: {\n\t\tstart: number;\n\t\tend?: number;\n\t\tdefault: string;\n\t\tcompatible: string[];\n\t}[];\n\tconstructor() {\n\t\tthis.char_def = new CharacterDefinition();\n\t\tthis.char_def.invoke_definition_map = new InvokeDefinitionMap();\n\t\tthis.character_category_definition = [];\n\t\tthis.category_mapping = [];\n\t}\n\tputLine(line: string) {\n\t\tconst parsed_category_def = CATEGORY_DEF_PATTERN.exec(line);\n\t\tif (parsed_category_def != null) {\n\t\t\tconst class_id = this.character_category_definition.length;\n\t\t\tconst char_class = CharacterDefinition.parseCharCategory(\n\t\t\t\tclass_id,\n\t\t\t\tparsed_category_def,\n\t\t\t);\n\t\t\tif (char_class == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.character_category_definition.push(char_class);\n\t\t\treturn;\n\t\t}\n\t\tconst parsed_category_mapping = CATEGORY_MAPPING_PATTERN.exec(line);\n\t\tif (parsed_category_mapping != null) {\n\t\t\tconst mapping = CharacterDefinition.parseCategoryMapping(\n\t\t\t\tparsed_category_mapping,\n\t\t\t);\n\t\t\tthis.category_mapping.push(mapping);\n\t\t}\n\t\tconst parsed_range_category_mapping =\n\t\t\tRANGE_CATEGORY_MAPPING_PATTERN.exec(line);\n\t\tif (parsed_range_category_mapping != null) {\n\t\t\tconst range_mapping = CharacterDefinition.parseRangeCategoryMapping(\n\t\t\t\tparsed_range_category_mapping,\n\t\t\t);\n\t\t\tthis.category_mapping.push(range_mapping);\n\t\t}\n\t}\n\tbuild() {\n\t\t// TODO If DEFAULT category does not exist, throw error\n\t\tif (!this.char_def.invoke_definition_map) {\n\t\t\tthrow new Error(\"invoke_definition_map is not initialized\");\n\t\t}\n\t\tthis.char_def.invoke_definition_map.init(\n\t\t\tthis.character_category_definition,\n\t\t);\n\t\tthis.char_def.initCategoryMappings(this.category_mapping);\n\t\treturn this.char_def;\n\t}\n}\n\nexport default CharacterDefinitionBuilder;\n","import ConnectionCosts from \"../ConnectionCosts\";\n\n/**\n * Builder class for constructing ConnectionCosts object\n * @constructor\n */\nclass ConnectionCostsBuilder {\n\tlines: number;\n\tconnection_cost?: ConnectionCosts;\n\tconstructor() {\n\t\tthis.lines = 0;\n\t}\n\tputLine(line: string) {\n\t\tif (this.lines === 0) {\n\t\t\tconst dimensions = line.split(\" \");\n\t\t\tconst forward_dimension = Number.parseInt(dimensions[0]);\n\t\t\tconst backward_dimension = Number.parseInt(dimensions[1]);\n\n\t\t\tif (forward_dimension < 0 || backward_dimension < 0) {\n\t\t\t\tthrow \"Parse error of matrix.def\";\n\t\t\t}\n\n\t\t\tthis.connection_cost = new ConnectionCosts(\n\t\t\t\tforward_dimension,\n\t\t\t\tbackward_dimension,\n\t\t\t);\n\t\t\tthis.lines++;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst costs = line.split(\" \");\n\n\t\tif (costs.length !== 3) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst forward_id = Number.parseInt(costs[0]);\n\t\tconst backward_id = Number.parseInt(costs[1]);\n\t\tconst cost = Number.parseInt(costs[2]);\n\n\t\tif (\n\t\t\tforward_id < 0 ||\n\t\t\tbackward_id < 0 ||\n\t\t\t!Number.isFinite(forward_id) ||\n\t\t\t!Number.isFinite(backward_id) ||\n\t\t\tthis.connection_cost?.forward_dimension! <= forward_id ||\n\t\t\tthis.connection_cost?.backward_dimension! <= backward_id\n\t\t) {\n\t\t\tthrow \"Parse error of matrix.def\";\n\t\t}\n\n\t\tthis.connection_cost?.put(forward_id, backward_id, cost);\n\t\tthis.lines++;\n\t\treturn this;\n\t}\n\tbuild(): ConnectionCosts {\n\t\tif (!this.connection_cost) {\n\t\t\tthrow new Error(\"ConnectionCosts is not initialized\");\n\t\t}\n\t\treturn this.connection_cost;\n\t}\n}\n\nexport default ConnectionCostsBuilder;\n"],"names":[],"version":3,"file":"kuromoji.js.map","sourceRoot":"../"}